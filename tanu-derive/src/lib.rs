extern crate proc_macro;

use eyre::{OptionExt, WrapErr};
use itertools::Itertools;
use once_cell::sync::Lazy;
use proc_macro::TokenStream;
use proc_macro2::Span;
use quote::{quote, ToTokens};
use std::{
    collections::{HashMap, HashSet},
    io::Read,
    path::PathBuf,
    sync::{Arc, Mutex},
};
use syn::{
    parse::Parse, parse_macro_input, punctuated::Punctuated, Expr, ExprLit, File, Ident, Item,
    ItemFn, Lit, LitStr, Meta, Token,
};
use walkdir::WalkDir;

static TEST_CASES: Lazy<Arc<Mutex<HashSet<TestCase>>>> =
    Lazy::new(|| Arc::new(Mutex::new(HashSet::new())));

/// Represent one parametrized test case.
#[derive(Debug, Clone, Hash, Eq, PartialEq)]
struct TestCase {
    /// Rust function name generated by tanu.
    func_name: String,
    /// Human friendly test case name listed by `cargo run ls`.
    test_name: String,
    // Unique ID to identify
    //id: String,
}

impl TestCase {
    /// Create a test case where `func`
    fn from_func_name(input: &Input, org_func_name: &str) -> TestCase {
        TestCase {
            func_name: generate_test_name_with_parameters(org_func_name, input),
            test_name: generate_test_name_with_parameters(org_func_name, input),
        }
    }
}

#[derive(Debug)]
#[allow(dead_code)]
struct TestModule {
    /// Module that contains the Rust `func_name` function.
    module: String,
    /// Rust function name.
    func_name: String,
    /// All the test cases discovered in the module.
    test_cases: Vec<TestCase>,
}

/// Represents arguments in the test attribute #[test(a, b; c)].
struct Input {
    /// Test arguments specified in the test attribute.
    args: Punctuated<Expr, Token![,]>,
    /// Test name specified in the test attribute.
    name: Option<LitStr>,
}

impl Parse for Input {
    fn parse(input: syn::parse::ParseStream) -> syn::Result<Self> {
        if input.is_empty() {
            Ok(Input {
                args: Default::default(),
                name: None,
            })
        } else {
            let args: Punctuated<Expr, Token![,]> =
                Punctuated::parse_separated_nonempty_with(input, Expr::parse)?;

            let name = if input.parse::<Token![;]>().is_ok() {
                input.parse::<LitStr>().ok()
            } else {
                None
            };

            Ok(Input { args, name })
        }
    }
}

/// Generates a unique function name for a test case.
/// - If a test name argument is provided (e.g., `#[test(a; xxx)]`), use it as the function name.
/// - Otherwise, generate a function name by concatenating the test parameters with `_`.
fn generate_test_name_with_parameters(org_func_name: &str, input: &Input) -> String {
    let func_name = org_func_name.to_string();

    if input.args.is_empty() {
        return format!("tanu_{func_name}");
    }

    let generated = match &input.name {
        Some(name_argument) => name_argument.value(),
        _ => {
            let args = input
                .args
                .iter()
                .filter_map(|expr| {
                    let lit: &Lit = match expr {
                        Expr::Lit(ExprLit { lit, .. }) => lit,
                        _ => {
                            panic!("not supported");
                        }
                    };
                    match lit {
                        Lit::Str(lit_str) => Some(lit_str.value()),
                        Lit::Int(lit_int) => Some(lit_int.to_string()),
                        _ => None,
                    }
                })
                .collect::<Vec<_>>()
                .join("_");
            format!("tanu_{func_name}_{args}")
        }
    };

    // Check if the generated function name is valid function name.
    if syn::parse_str::<Ident>(&generated).is_err() {
        panic!(
            r#"Test case generation error! The provided test parameters contain
 invalid characters that cannot be used in a function name (function name: {generated}).
 Please specify a valid test name using only letters, numbers, and underscores."#
        );
    }

    generated
}

/// #[test] attribute registers the test function in tanu runner.
/// Without this attribute, tanu can not discover test cases.
#[proc_macro_attribute]
pub fn test(args: TokenStream, input: TokenStream) -> TokenStream {
    //println!("args = {args:?} span = {:?}", Span::call_site());
    let input_args = parse_macro_input!(args as Input);
    let input_fn = parse_macro_input!(input as ItemFn);

    let func_name_inner = &input_fn.sig.ident;
    let test_case = TestCase::from_func_name(&input_args, &func_name_inner.to_string());

    let not_duplicated = TEST_CASES
        .lock()
        .expect("failed to accuire test case lock")
        .insert(test_case.clone());
    if !not_duplicated {
        panic!(
            r#"tanu does not yet support registering test with the exactly same signature.
 please check the name of this function "{func_name_inner}" and try again."#
        );
    }

    let func_name = Ident::new(&test_case.func_name, Span::call_site());
    let args = input_args.args.to_token_stream();
    let output = quote! {
        #input_fn

        pub(crate) async fn #func_name() -> tanu::eyre::Result<()> {
            // TODO don't wrap in eyre if the error type is already eyre::Report.
            #func_name_inner(#args).await.map_err(|e| tanu::eyre::eyre!(Box::new(e)))
        }
    };

    output.into()
}

fn find_crate_root() -> eyre::Result<PathBuf> {
    let dir = std::env::var("CARGO_MANIFEST_DIR")?;
    Ok(dir.into())
}

fn discover_tests() -> eyre::Result<Vec<TestModule>> {
    let root = find_crate_root()?;
    let source_paths: Vec<_> = WalkDir::new(root)
        .into_iter()
        .filter_map(|entry| {
            let path = entry.ok()?.into_path();
            let ext = path.extension()?;
            if ext.eq_ignore_ascii_case("rs") {
                Some(path)
            } else {
                None
            }
        })
        .collect();

    let mut test_modules = Vec::<TestModule>::new();
    for source_path in source_paths {
        let mut source_file = std::fs::File::open(&source_path)
            .wrap_err_with(|| format!("could not open file: {}", source_path.display()))?;
        let mut code = String::new();
        source_file.read_to_string(&mut code)?;

        let file = syn::parse_file(&code)?;
        test_modules.extend(extract_module_and_test(
            source_path
                .file_stem()
                .ok_or_eyre("invalid source file name")?
                .to_str()
                .ok_or_eyre("invalid source file name")?,
            file,
        ));
    }

    Ok(test_modules)
}

fn extract_module_and_test(module: &str, input: File) -> Vec<TestModule> {
    let mut test_modules = Vec::new();
    for item in input.items {
        if let Item::Fn(item_fn) = item {
            //println!("fn = {item_fn:#?}");
            //println!(
            //    "extract_module_and_test {item_fn:#?} span = {:?}",
            //    item_fn.span()
            //);
            let mut is_test = false;
            let mut test_cases = Vec::new();
            for attr in item_fn.attrs {
                if attr.path().is_ident("test") {
                    is_test = true;

                    //println!("attr = {attr:#?}");
                    match &attr.meta {
                        // There is no arguments in test attribute which is #[test]
                        Meta::Path(_path) => {
                            let test_case = TestCase {
                                func_name: format!("tanu_{}", item_fn.sig.ident),
                                test_name: format!("tanu_{}", item_fn.sig.ident),
                            };
                            //println!(
                            //    "registering name = {} func_name = {}",
                            //    test_case.test_name, test_case.func_name
                            //);
                            test_cases.push(test_case);
                        }
                        // There is arguments to parse from test attribute which is like #[test(xxx, ...)]
                        Meta::List(_list) => match attr.parse_args_with(Input::parse) {
                            Ok(test_case_token) => {
                                let test_case = TestCase::from_func_name(
                                    &test_case_token,
                                    &item_fn.sig.ident.to_string(),
                                );
                                //println!(
                                //    "registering name = {} func_name = {}",
                                //    test_case.test_name, test_case.func_name
                                //);
                                test_cases.push(test_case);
                            }
                            Err(e) => {
                                eprintln!("failed to parse attributes in #[test]: {e:#}");
                            }
                        },
                        _ => {}
                    }
                }
            }
            if is_test {
                test_modules.push(TestModule {
                    module: module.to_owned(),
                    func_name: item_fn.sig.ident.to_string(),
                    test_cases,
                });
            }
        }
    }

    test_modules
}

#[proc_macro_attribute]
pub fn main(_args: TokenStream, input: TokenStream) -> TokenStream {
    let main_fn = parse_macro_input!(input as ItemFn);

    let test_modules = discover_tests().expect("failed to discover test cases");
    let test_modules: HashMap<String, String> = test_modules
        .iter()
        .flat_map(|module| {
            let module_name = module.module.clone();
            module.test_cases.iter().map(move |test_case| {
                (
                    test_case.func_name.clone(),
                    if module_name == "main" {
                        "crate".into()
                    } else {
                        module_name.clone()
                    },
                )
            })
        })
        .collect();

    let (test_mods, test_names, func_names): (Vec<_>, Vec<_>, Vec<_>) = TEST_CASES
        .lock()
        .expect("failed to accuire test case lock")
        .iter()
        .map(|f| {
            //println!("extracting test case {}", f.func_name);
            let test_module = test_modules.get(&f.func_name).expect("module not found");
            (
                Ident::new(test_module, Span::call_site()),
                f.test_name.clone(),
                Ident::new(&f.func_name, Span::call_site()),
            )
        })
        .multiunzip();
    //println!("{test_cases:?}");

    let output = quote! {
        fn run() -> tanu::Runner {
            let mut runner = tanu::Runner::new();
            #(
            runner.add_test(#test_names, stringify!(#test_mods), Box::new(|| Box::pin(#test_mods::#func_names())));
            )*
            runner
        }

        #main_fn
    };

    output.into()
}
