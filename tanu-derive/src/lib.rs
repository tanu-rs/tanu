//! # Tanu Derive
//!
//! Procedural macros for the tanu WebAPI testing framework.
//!
//! This crate provides the `#[tanu::test]` and `#[tanu::main]` procedural macros
//! that enable the core functionality of tanu's test discovery and execution system.
//!
//! ## Macros
//!
//! - `#[tanu::test]` - Marks async functions as tanu test cases
//! - `#[tanu::test(param)]` - Creates parameterized test cases  
//! - `#[tanu::main]` - Generates the main function for test discovery
//!
//! These macros are automatically re-exported by the main `tanu` crate,
//! so users typically don't need to import this crate directly.

extern crate proc_macro;

use eyre::WrapErr;
use itertools::Itertools;
use once_cell::sync::Lazy;
use proc_macro::TokenStream;
use proc_macro2::Span;
use quote::{quote, ToTokens};
use std::{
    collections::{HashMap, HashSet},
    io::Read,
    path::{Path, PathBuf},
    sync::{Arc, Mutex},
};
use syn::{
    parse::Parse, parse_macro_input, punctuated::Punctuated, Expr, ExprCall, ExprLit, ExprPath,
    File, Ident, Item, ItemFn, Lit, LitStr, Meta, ReturnType, Signature, Token, Type,
};
use walkdir::WalkDir;

static TEST_CASES: Lazy<Arc<Mutex<HashSet<TestCase>>>> =
    Lazy::new(|| Arc::new(Mutex::new(HashSet::new())));

/// Represent one parametrized test case.
#[derive(Debug, Clone, Hash, Eq, PartialEq)]
struct TestCase {
    /// Rust function name generated by tanu.
    func_name: String,
    /// Human friendly test case name listed by `cargo run ls`.
    test_name: String,
}

impl TestCase {
    /// Create a test case where `func`
    fn from_func_name(input: &Input, org_func_name: &str) -> TestCase {
        let test_name = generate_test_name(org_func_name, input);
        let func_name = format!("tanu_{test_name}").replace("::", "_");
        if syn::parse_str::<Ident>(&func_name).is_err() {
            panic!(
                r#"Test case generation error! The provided test parameters contain
 invalid characters that cannot be used in a function name (function name: {func_name}).
 Please specify a valid test name using only letters, numbers, and underscores."#
            );
        }
        TestCase {
            func_name,
            test_name,
        }
    }
}

#[derive(Debug)]
#[allow(dead_code)]
struct TestModule {
    /// Module that contains the Rust `func_name` function.
    module: String,
    /// Rust function name.
    func_name: String,
    /// All the test cases discovered in the module.
    test_cases: Vec<TestCase>,
}

/// Represents arguments in the test attribute #[test(a, b; c)].
struct Input {
    /// Test arguments specified in the test attribute.
    args: Punctuated<Expr, Token![,]>,
    /// Test name specified in the test attribute.
    name: Option<LitStr>,
}

impl Parse for Input {
    fn parse(input: syn::parse::ParseStream) -> syn::Result<Self> {
        if input.is_empty() {
            Ok(Input {
                args: Default::default(),
                name: None,
            })
        } else {
            let args: Punctuated<Expr, Token![,]> =
                Punctuated::parse_separated_nonempty_with(input, Expr::parse)?;

            let name = if input.parse::<Token![;]>().is_ok() {
                input.parse::<LitStr>().ok()
            } else {
                None
            };

            Ok(Input { args, name })
        }
    }
}

/// - If a test name argument is provided (e.g., `#[test(a; xxx)]`), use it as the function name.
/// - Otherwise, generate a function name by concatenating the test parameters with `_`.
fn generate_test_name(org_func_name: &str, input: &Input) -> String {
    let func_name = org_func_name.to_string();

    if input.args.is_empty() {
        return func_name.to_string();
    }

    let stringified_args = match &input.name {
        Some(name_argument) => name_argument.value(),
        _ => input
            .args
            .iter()
            .filter_map(|expr| match expr {
                Expr::Lit(ExprLit { lit, .. }) => match lit {
                    Lit::Str(lit_str) => Some(lit_str.value()),
                    other_literal => Some(quote!(#other_literal).to_string()),
                },
                expr @ Expr::Path(_) | expr @ Expr::Call(_) => extract_and_stringify_option(expr),
                other_expr => Some(quote!(#other_expr).to_string()),
            })
            .map(|s| {
                s.replace("+=", "_add_")
                    .replace("+", "_add_")
                    .replace("-=", "_sub_")
                    .replace("-", "_sub_")
                    .replace("/=", "_div_")
                    .replace("/", "_div_")
                    .replace("*=", "_mul_")
                    .replace("*", "_mul_")
                    .replace("%=", "_mod_")
                    .replace("%", "_mod_")
                    .replace("==", "_eq_")
                    .replace("!=", "_nq_")
                    .replace("&&", "_and_")
                    .replace("||", "_or_")
                    .replace("!", "not_")
                    .replace("&=", "_and_")
                    .replace("&", "_and_")
                    .replace("|=", "_or_")
                    .replace("|", "_or_")
                    .replace("^=", "_xor_")
                    .replace("^", "_xor_")
                    .replace("<<=", "_lshift_")
                    .replace("<<", "_lshift_")
                    .replace("<=", "_le_")
                    .replace("<", "_lt_")
                    .replace(">>=", "_rshift_")
                    .replace(">>", "_rshift_")
                    .replace(">=", "_ge_")
                    .replace(">", "_gt_")
                    .replace("&mut ", "")
                    .replace("*mut ", "")
                    .replace("&", "")
                    .replace("*", "")
                    .replace(" :: ", "_")
                    .replace("\\", "")
                    .replace("/", "")
                    .replace("\"", "")
                    .replace("(", "")
                    .replace(")", "")
                    .replace("{", "")
                    .replace("}", "")
                    .replace("[", "")
                    .replace("]", "")
                    .replace(" ", "")
                    .replace(",", "_")
                    .replace(".", "_")
                    .to_lowercase()
            })
            .collect::<Vec<_>>()
            .join("_"),
    };

    format!("{func_name}::{stringified_args}")
}

#[derive(Debug, Eq, PartialEq)]
enum ErrorCrate {
    Eyre,
    AnythingElse,
}

/// Inspects the current function's signature to determine which error crate is being used.
///
/// This function analyzes the return type of the function to detect whether it is using
/// `eyre::Result` or another error result type. It then enables conditional handling based
/// on the error crate in use (e.g., wrapping non-`eyre::Result` types in an `eyre::Result`).
///
/// **Limitation:**
/// Due to the inherent limitations of proc macros, this function can only detect error types
/// when `eyre` is referenced using its fully qualified path (for example, `eyre::Result`).
///
/// For further details and discussion on this limitation, see:
/// https://users.rust-lang.org/t/in-a-proc-macro-attribute-procedural-macro-how-to-get-the-full-typepath-of-some-type/107713/2
fn inspect_error_crate(sig: &Signature) -> ErrorCrate {
    match &sig.output {
        ReturnType::Default => panic!("return type needs to be other than ()"),
        ReturnType::Type(_, ty) => {
            let Type::Path(type_path) = ty.as_ref() else {
                panic!("failed to get return type path");
            };

            let path = &type_path.path;
            match (path.segments.first(), path.segments.last()) {
                (Some(first), Some(last)) => {
                    if first.ident == "eyre" && last.ident == "Result" {
                        ErrorCrate::Eyre
                    } else {
                        ErrorCrate::AnythingElse
                    }
                }
                _ => {
                    panic!("unexpected return type");
                }
            }
        }
    }
}

#[allow(dead_code)]
/// Returns the name of the variant of the given expression.
fn get_expr_variant_name(expr: &Expr) -> &'static str {
    match expr {
        Expr::Array(_) => "Array",
        Expr::Assign(_) => "Assign",
        Expr::Async(_) => "Async",
        Expr::Await(_) => "Await",
        Expr::Binary(_) => "Binary",
        Expr::Block(_) => "Block",
        Expr::Break(_) => "Break",
        Expr::Call(_) => "Call",
        Expr::Cast(_) => "Cast",
        Expr::Closure(_) => "Closure",
        Expr::Continue(_) => "Continue",
        Expr::Field(_) => "Field",
        Expr::ForLoop(_) => "ForLoop",
        Expr::Group(_) => "Group",
        Expr::If(_) => "If",
        Expr::Index(_) => "Index",
        Expr::Let(_) => "Let",
        Expr::Lit(_) => "Lit",
        Expr::Loop(_) => "Loop",
        Expr::Macro(_) => "Macro",
        Expr::Match(_) => "Match",
        Expr::MethodCall(_) => "MethodCall",
        Expr::Paren(_) => "Paren",
        Expr::Path(_) => "Path",
        Expr::Range(_) => "Range",
        Expr::Reference(_) => "Reference",
        Expr::Repeat(_) => "Repeat",
        Expr::Return(_) => "Return",
        Expr::Struct(_) => "Struct",
        Expr::Try(_) => "Try",
        Expr::TryBlock(_) => "TryBlock",
        Expr::Tuple(_) => "Tuple",
        Expr::Unary(_) => "Unary",
        Expr::Unsafe(_) => "Unsafe",
        Expr::Verbatim(_) => "Verbatim",
        Expr::While(_) => "While",
        Expr::Yield(_) => "Yield",
        _ => "Unknown",
    }
}

fn extract_and_stringify_option(expr: &Expr) -> Option<String> {
    match expr {
        Expr::Call(ExprCall { func, args, .. }) => {
            if let Expr::Path(ExprPath { path, .. }) = &**func {
                let segment = path.segments.last()?;
                if segment.ident == "Some" {
                    match args.first()? {
                        Expr::Lit(ExprLit { lit, .. }) => match lit {
                            Lit::Str(lit_str) => {
                                return Some(lit_str.value());
                            }
                            other_type_of_literal => {
                                return Some(other_type_of_literal.to_token_stream().to_string());
                            }
                        },
                        first_arg => {
                            return Some(quote!(#first_arg).to_string());
                        }
                    }
                }
            }
        }
        Expr::Path(ExprPath { path, .. }) => {
            if path.get_ident()? == "None" {
                return Some("None".into());
            }
        }
        _ => {}
    }

    None
}

/// Marks an async function as a tanu test case.
///
/// This attribute registers the function with tanu's test discovery system,
/// making it available for execution via the test runner.
///
/// # Basic Usage
///
/// ```rust,ignore
/// #[tanu::test]
/// async fn my_test() -> eyre::Result<()> {
///     // Test implementation
///     Ok(())
/// }
/// ```
///
/// # Parameterized Tests
///
/// The macro supports parameterized testing by accepting arguments:
///
/// ```rust,ignore
/// #[tanu::test(200)]
/// #[tanu::test(404)]
/// #[tanu::test(500)]
/// async fn test_status_codes(status: u16) -> eyre::Result<()> {
///     // Test with different status codes
///     Ok(())
/// }
/// ```
///
/// # Requirements
///
/// - Function must be `async`
/// - Function must return a `Result<T, E>` type
/// - Supported Result types: `eyre::Result`, `anyhow::Result`, `std::result::Result`
///
/// # Error Handling
///
/// The macro automatically handles different Result types and integrates
/// with tanu's error reporting system for enhanced error messages and backtraces.
#[proc_macro_attribute]
pub fn test(args: TokenStream, input: TokenStream) -> TokenStream {
    let input_args = parse_macro_input!(args as Input);
    let input_fn = parse_macro_input!(input as ItemFn);

    let func_name_inner = &input_fn.sig.ident;
    let test_case = TestCase::from_func_name(&input_args, &func_name_inner.to_string());

    match TEST_CASES.lock() {
        Ok(mut lock) => lock.insert(test_case.clone()),
        Err(e) => {
            eprintln!("Failed to acquire test case lock: {e}");
            return quote! { #input_fn }.into();
        }
    };

    let func_name = Ident::new(&test_case.func_name, Span::call_site());
    let args = input_args.args.to_token_stream();

    // tanu internally relies on the `eyre` and `color-eyre` crates for error handling.
    // since `tanu::Runner` expects test functions to return an `eyre::Result`, the macro
    // generates two types of code.
    //
    // - If a test function explicitly returns `eyre::Result`, the macro will generate
    //   a function that also returns `eyre::Result` without modification.
    //
    // - If the test function returns another result type (e.g., `anyhow::Result`),
    //   the macro will automatically wrap the return value in an `eyre::Result`.
    let error_crate = inspect_error_crate(&input_fn.sig);
    let output = if error_crate == ErrorCrate::Eyre {
        quote! {
            #input_fn
            pub(crate) async fn #func_name() -> tanu::eyre::Result<()> {
                #func_name_inner(#args).await
            }
        }
    } else {
        quote! {
            #input_fn
            pub(crate) async fn #func_name() -> tanu::eyre::Result<()> {
                #func_name_inner(#args).await.map_err(|e| tanu::eyre::eyre!(Box::new(e)))
            }
        }
    };

    output.into()
}

fn find_crate_root() -> eyre::Result<PathBuf> {
    let dir = std::env::var("CARGO_MANIFEST_DIR")?;
    Ok(dir.into())
}

fn discover_tests() -> eyre::Result<Vec<TestModule>> {
    let root = find_crate_root()?;

    // Look up all rust source files.
    let source_paths: Vec<_> = WalkDir::new(root)
        .into_iter()
        .filter_map(|entry| {
            let path = entry.ok()?.into_path();
            let ext = path.extension()?;
            if ext.eq_ignore_ascii_case("rs") {
                Some(path)
            } else {
                None
            }
        })
        .collect();

    let mut test_modules = Vec::<TestModule>::new();
    for source_path in source_paths {
        let mut source_file = std::fs::File::open(&source_path)
            .wrap_err_with(|| format!("could not open file: {}", source_path.display()))?;
        let mut code = String::new();
        source_file.read_to_string(&mut code)?;

        let file = syn::parse_file(&code)?;
        let Some(module) = extract_module_path(&source_path) else {
            continue;
        };
        test_modules.extend(extract_module_and_test(&module, file));
    }

    Ok(test_modules)
}

// Extract module path "foo::bar::baz" from path "/xxxx/src/foo/bar/baz.rs".
fn extract_module_path(path: &Path) -> Option<String> {
    let src_index = path.iter().position(|p| p == "src")?;
    let module_path: Vec<_> = path.iter().skip(src_index + 1).collect();
    let module_path_str = module_path
        .iter()
        .filter_map(|p| p.to_str())
        .map(|s| s.strip_suffix(".rs").unwrap_or(s)) // Remove ".rs" extension if present
        .filter(|s| *s != "mod")
        .collect::<Vec<_>>()
        .join("::");
    Some(module_path_str)
}

/// Test if the function has #[tanu::test] attribute.
fn has_test_attribute(path: &syn::Path) -> bool {
    // The function has #[test].
    let has_test = path.is_ident("test");
    // The function has #[tanu::test].
    let has_tanu_test = match (path.segments.first(), path.segments.last()) {
        (Some(first), Some(last)) => {
            path.segments.len() == 2 && first.ident == "tanu" && last.ident == "test"
        }
        _ => false,
    };

    has_test || has_tanu_test
}

fn extract_module_and_test(module: &str, input: File) -> Vec<TestModule> {
    let mut test_modules = Vec::new();
    for item in input.items {
        if let Item::Fn(item_fn) = item {
            let mut is_test = false;
            let mut test_cases = Vec::new();
            for attr in item_fn.attrs {
                if has_test_attribute(attr.path()) {
                    is_test = true;

                    match &attr.meta {
                        // There is no arguments in test attribute which is #[test]
                        Meta::Path(_path) => {
                            let test_case = TestCase {
                                func_name: format!("tanu_{}", item_fn.sig.ident),
                                test_name: format!("tanu_{}", item_fn.sig.ident),
                            };
                            test_cases.push(test_case);
                        }
                        // There is arguments to parse from test attribute which is like #[test(xxx, ...)]
                        Meta::List(_list) => match attr.parse_args_with(Input::parse) {
                            Ok(test_case_token) => {
                                let test_case = TestCase::from_func_name(
                                    &test_case_token,
                                    &item_fn.sig.ident.to_string(),
                                );
                                test_cases.push(test_case);
                            }
                            Err(e) => {
                                eprintln!("failed to parse attributes in #[test]: {e:#}");
                            }
                        },
                        _ => {}
                    }
                }
            }
            if is_test {
                test_modules.push(TestModule {
                    module: module.to_owned(),
                    func_name: item_fn.sig.ident.to_string(),
                    test_cases,
                });
            }
        }
    }

    test_modules
}

/// Generates the test discovery and registration code for tanu.
///
/// This attribute should be applied to your main function alongside `#[tokio::main]`.
/// It automatically discovers all functions marked with `#[tanu::test]` and registers
/// them with the test runner.
///
/// # Usage
///
/// ```rust,ignore
/// #[tanu::main]
/// #[tokio::main]
/// async fn main() -> eyre::Result<()> {
///     let runner = run();
///     let app = tanu::App::new();
///     app.run(runner).await?;
///     Ok(())
/// }
/// ```
///
/// # What It Does
///
/// The macro performs compile-time test discovery by:
/// 1. Scanning the codebase for `#[tanu::test]` annotated functions
/// 2. Generating a `run()` function that returns a configured `Runner`
/// 3. Registering all discovered tests with the runner
/// 4. Setting up proper module organization and test metadata
///
/// # Requirements
///
/// - Must be used with `#[tokio::main]` for async support
/// - The main function should return a `Result` type
/// - All test functions must be marked with `#[tanu::test]`
///
/// # Generated Code
///
/// The macro generates a `run()` function that you can use to obtain
/// a pre-configured test runner with all your tests registered.
#[proc_macro_attribute]
pub fn main(_args: TokenStream, input: TokenStream) -> TokenStream {
    let main_fn = parse_macro_input!(input as ItemFn);

    let test_modules = discover_tests().expect("failed to discover test cases");
    // Create a HashMap mapping test function names to their module paths.
    // Using Vec<String> as the value allows multiple test functions with the same name
    // to exist across different modules.
    let test_modules: HashMap<String, Vec<String>> = test_modules
        .iter()
        .flat_map(|module| {
            let module_name = module.module.clone();
            module.test_cases.iter().map(move |test_case| {
                (
                    test_case.func_name.clone(),
                    if module_name == "main" {
                        "crate".into()
                    } else {
                        module_name.clone()
                    },
                )
            })
        })
        .fold(HashMap::new(), |mut acc, (func_name, module_name)| {
            acc.entry(func_name).or_default().push(module_name);
            acc
        });

    let (test_mods, test_names, func_names): (Vec<_>, Vec<_>, Vec<_>) = match TEST_CASES.lock() {
        Ok(lock) => lock
            .iter()
            .flat_map(|f| {
                test_modules
                    .get(&f.func_name)
                    .into_iter() // This safely handles None by returning an empty iterator
                    .flatten() // Flatten the Vec<String> to String
                    .filter_map(|module_name| {
                        let test_module_path = match syn::parse_str::<syn::Path>(module_name) {
                            Ok(path) => path,
                            Err(e) => {
                                eprintln!("failed to parse module path '{module_name}': {e}");
                                return None;
                            }
                        };

                        Some((
                            test_module_path,
                            f.test_name.clone(),
                            Ident::new(&f.func_name, Span::call_site()),
                        ))
                    })
            })
            .multiunzip(),
        Err(e) => {
            eprintln!("failed to acquire test case lock: {e}");
            (Vec::new(), Vec::new(), Vec::new())
        }
    };

    let output = quote! {
        fn run() -> tanu::Runner {
            let mut runner = tanu::Runner::new();
            #(
            runner.add_test(
                #test_names,
                &stringify!(#test_mods).replace(" ", ""),
                std::sync::Arc::new(|| Box::pin(#test_mods::#func_names()))
            );
            )*
            runner
        }

        #main_fn
    };

    output.into()
}

#[cfg(test)]
mod test {
    use crate::Input;

    use super::{ErrorCrate, Expr, Path, TestCase};
    use test_case::test_case;

    #[test_case("test" => true; "test")]
    #[test_case("tanu::test" => true; "tanu_test")]
    #[test_case("tanu::foo::test" => false; "not_tanu_test")]
    #[test_case("foo::test" => false; "also_not_tanu_test")]
    fn has_test_attribute(s: &str) -> bool {
        let path: syn::Path = syn::parse_str(s).expect("Failed to parse path");
        super::has_test_attribute(&path)
    }

    #[test_case("/home/yukinari/tanu/src/main.rs", "main"; "main")]
    #[test_case("/home/yukinari/tanu/src/foo.rs", "foo"; "foo")]
    #[test_case("/home/yukinari/tanu/src/foo/bar.rs", "foo::bar"; "foo::bar")]
    #[test_case("/home/yukinari/tanu/src/foo/bar/baz.rs", "foo::bar::baz"; "foo::bar::baz")]
    #[test_case("/home/yukinari/tanu/src/foo/bar/mod.rs", "foo::bar"; "foo::bar::mod")]
    fn test_extract_module_path(path: &str, module_path: &str) {
        let path = Path::new(path);
        let extracted_module = super::extract_module_path(path);
        assert_eq!(extracted_module, Some(module_path.to_string()));
    }

    #[test_case("fn foo() -> eyre::Result" => ErrorCrate::Eyre; "eyre")]
    #[test_case("fn foo() -> anyhow::Result" => ErrorCrate::AnythingElse; "anyhow")]
    #[test_case("fn foo() -> miette::Result" => ErrorCrate::AnythingElse; "miette")]
    #[test_case("fn foo() -> Result" => ErrorCrate::AnythingElse; "std_result")]
    fn inspect_error_crate(s: &str) -> ErrorCrate {
        let sig: syn::Signature = syn::parse_str(s).expect("failed to parse function signature");
        super::inspect_error_crate(&sig)
    }

    #[test_case("Some(1)" => Some("1".into()); "Some with int")]
    #[test_case("Some(\"test\")" => Some("test".into()); "Some with string")]
    #[test_case("Some(true)" => Some("true".into()); "Some with boolean")]
    #[test_case("Some(1.0)" => Some("1.0".into()); "Some with float")]
    #[test_case("Some(StatusCode::OK)" => Some("StatusCode :: OK".into()); "Some third party type")]
    #[test_case("Some(\"foo\".to_string())" => Some("\"foo\" . to_string ()".into()); "Some expression")]
    #[test_case("None" => Some("None".into()); "None")]
    fn extract_and_stringify_option(s: &str) -> Option<String> {
        let expr: Expr = syn::parse_str(s).expect("failed to parse expression");
        super::extract_and_stringify_option(&expr)
    }

    #[allow(clippy::erasing_op)]
    #[test_case("a, b; \"test_name\"" => "foo::test_name"; "with test name")]
    #[test_case("1+1" => "foo::1_add_1"; "with add expression")]
    #[test_case("1+=1" => "foo::1_add_1"; "with add assignment expression")]
    #[test_case("1-1" => "foo::1_sub_1"; "with sub expression")]
    #[test_case("1-=1" => "foo::1_sub_1"; "with sub assignment expression")]
    #[test_case("1/1" => "foo::1_div_1"; "with div expression")]
    #[test_case("1/=1" => "foo::1_div_1"; "with div assignment expression")]
    #[test_case("1*1" => "foo::1_mul_1"; "with mul expression")]
    #[test_case("1*=1" => "foo::1_mul_1"; "with mul assignment expression")]
    #[test_case("1%1" => "foo::1_mod_1"; "with mod expression")]
    #[test_case("1%=1" => "foo::1_mod_1"; "with mod assignment expression")]
    #[test_case("1==1" => "foo::1_eq_1"; "with eq expression")]
    #[test_case("1!=1" => "foo::1_nq_1"; "with neq expression")]
    #[test_case("1<1" => "foo::1_lt_1"; "with lt expression")]
    #[test_case("1>1" => "foo::1_gt_1"; "with gt expression")]
    #[test_case("1<=1" => "foo::1_le_1"; "with le expression")]
    #[test_case("1>=1" => "foo::1_ge_1"; "with ge expression")]
    #[test_case("true&&false" => "foo::true_and_false"; "with and expression")]
    #[test_case("true||false" => "foo::true_or_false"; "with or expression")]
    #[test_case("!true" => "foo::not_true"; "with not expression")]
    #[test_case("1&1" => "foo::1_and_1"; "with bitwise and expression")]
    #[test_case("1&=1" => "foo::1_and_1"; "with bitwise and assignment expression")]
    #[test_case("1|1" => "foo::1_or_1"; "with bitwise or expression")]
    #[test_case("1|=1" => "foo::1_or_1"; "with bitwise or assignment expression")]
    #[test_case("1^1" => "foo::1_xor_1"; "with xor expression")]
    #[test_case("1^=1" => "foo::1_xor_1"; "with xor assignment expression")]
    #[test_case("1<<1" => "foo::1_lshift_1"; "with left shift expression")]
    #[test_case("1<<=1" => "foo::1_lshift_1"; "with left shift assignment expression")]
    #[test_case("1>>1" => "foo::1_rshift_1"; "with right shift expression")]
    #[test_case("1>>=1" => "foo::1_rshift_1"; "with right shift assignment expression")]
    #[test_case("\"bar\".to_string()" => "foo::bar_to_string"; "to_string")]
    #[test_case("1+1*2" => "foo::1_add_1_mul_2"; "with add and mul expression")]
    #[test_case("1*(2+3)" => "foo::1_mul_2_add_3"; "with mul and add expression")]
    #[test_case("1+2-3" => "foo::1_add_2_sub_3"; "with add and sub expression")]
    #[test_case("1/2*3" => "foo::1_div_2_mul_3"; "with div and mul expression")]
    #[test_case("1%2+3" => "foo::1_mod_2_add_3"; "with mod and add expression")]
    #[test_case("1==2&&3!=4" => "foo::1_eq_2_and_3_nq_4"; "with eq and and expression")]
    #[test_case("true||false&&true" => "foo::true_or_false_and_true"; "with or and and expression")]
    #[test_case("!(1+2)" => "foo::not_1_add_2"; "with not and add expression")]
    #[test_case("1&2|3^4" => "foo::1_and_2_or_3_xor_4"; "with bitwise and, or, xor expression")]
    #[test_case("1<<2>>3" => "foo::1_lshift_2_rshift_3"; "with left shift and right shift expression")]
    #[test_case("Some(1+2)" => "foo::1_add_2"; "with Some and add expression")]
    #[test_case("None" => "foo::none"; "with None")]
    #[test_case("[1, 2]" => "foo::1_2"; "with array")]
    #[test_case("vec![1, 2]" => "foo::vecnot_1_2"; "with macro")] // TODO should parse macro so that it won't have "not"
    #[test_case("\"foo\".to_string().len()" => "foo::foo_to_string_len"; "with function call chain")]
    #[test_case("0.5+0.3" => "foo::0_5_add_0_3"; "with floating point add")] // TODO should be foo::05_add_03
    #[test_case("-10" => "foo::_sub_10"; "with negative number")] // TODO should be neg_10
    #[test_case("1.0e10" => "foo::1_0e10"; "with scientific notation")] // TODO should be foo::10e10
    #[test_case("0xff" => "foo::0xff"; "with hex literal")]
    #[test_case("0o777" => "foo::0o777"; "with octal literal")]
    #[test_case("0b1010" => "foo::0b1010"; "with binary literal")]
    #[test_case("\"hello\" + \"world\"" => "foo::hello_add_world"; "with string concatenation")]
    #[test_case("format!(\"{}{}\", 1, 2)" => "foo::formatnot__1_2"; "with format macro")] // TODO should be format_1_2
    #[test_case("r#\"raw string\"#" => "foo::rawstring"; "with raw string")]
    //#[test_case("\n\t\r" => "foo::n_t_r"; "with escape sequences")] // TODO this does not work yet
    #[test_case("(1, \"hello\", true)" => "foo::1_hello_true"; "with mixed tuple")]
    //#[test_case("HashSet::from([1, 2, 3])" => "foo::hashsetfrom_1_2_3"; "with collection construction")] // TODO should be 1_2_3
    //#[test_case("add(1, 2)" => "foo::add1_2"; "with function call")] // This does not work
    //#[test_case("HashSet::from([1, 2, 3])" => "foo::hashsetfrom_1_2_3"; "with collection construction")] // TODO should be 1_2_3
    #[test_case("vec![1..5]" => "foo::vecnot_1__5"; "with range in macro")]
    //#[test_case("add(1, 2)" => "foo::add1_2"; "with function call")] // This does not work
    #[test_case("x.map(|v| v+1)" => "foo::x_map_or_v_or_v_add_1"; "with closure")]
    #[test_case("a.into()" => "foo::a_into"; "with method call no args")]
    // should be a_parse_i32_unwrap
    #[test_case("a.parse::<i32>().unwrap()" => "foo::a_parse__lt_i32_gt__unwrap"; "with turbofish syntax")]
    // #[test_case("if x { 1 } else { 2 }" => "foo::if_x_1_else_2"; "with if expression")]
    // #[test_case("match x { Some(v) => v, None => 0 }" => "foo::match_x_somev_v_none_0"; "with match expression")]
    //#[test_case("Box::new(1)" => "foo::boxnew_1"; "with box allocation")]
    //#[test_case("Rc::new(vec![1, 2])" => "foo::rcnew_vecnot_1_2"; "with reference counting")]
    //#[test_case("<Vec<i32> as IntoIterator>::into_iter" => "foo::veci32_as_intoiterator_into_iter"; "with type casting")]
    // TODO should be 1_10
    #[test_case("1..10" => "foo::1__10"; "with range")]
    //#[test_case("1..=10" => "foo::1_10"; "with inclusive range")]
    //#[test_case("..10" => "foo::_10"; "with range to")]
    //#[test_case("10.." => "foo::10_"; "with range from")]
    fn generate_test_name(args: &str) -> String {
        let input_args: Input = syn::parse_str(args).expect("failed to parse input args");
        let test_case = TestCase::from_func_name(&input_args, "foo");
        test_case.test_name
    }
}
