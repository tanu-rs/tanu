extern crate proc_macro;

use eyre::{OptionExt, WrapErr};
use itertools::Itertools;
use once_cell::sync::Lazy;
use proc_macro::TokenStream;
use proc_macro2::Span;
use quote::{quote, ToTokens};
use std::{
    collections::{HashMap, HashSet},
    io::Read,
    path::PathBuf,
    sync::{Arc, Mutex},
};
use syn::{
    parse::Parse, parse_macro_input, punctuated::Punctuated, Expr, ExprLit, File, Ident, Item,
    ItemFn, Lit, LitStr, Meta, ReturnType, Signature, Token, Type,
};
use walkdir::WalkDir;

static TEST_CASES: Lazy<Arc<Mutex<HashSet<TestCase>>>> =
    Lazy::new(|| Arc::new(Mutex::new(HashSet::new())));

/// Represent one parametrized test case.
#[derive(Debug, Clone, Hash, Eq, PartialEq)]
struct TestCase {
    /// Rust function name generated by tanu.
    func_name: String,
    /// Human friendly test case name listed by `cargo run ls`.
    test_name: String,
    // Unique ID to identify
    //id: String,
}

impl TestCase {
    /// Create a test case where `func`
    fn from_func_name(input: &Input, org_func_name: &str) -> TestCase {
        TestCase {
            func_name: generate_test_name_with_parameters(org_func_name, input, Some("tanu")),
            test_name: generate_test_name_with_parameters(org_func_name, input, None),
        }
    }
}

#[derive(Debug)]
#[allow(dead_code)]
struct TestModule {
    /// Module that contains the Rust `func_name` function.
    module: String,
    /// Rust function name.
    func_name: String,
    /// All the test cases discovered in the module.
    test_cases: Vec<TestCase>,
}

/// Represents arguments in the test attribute #[test(a, b; c)].
struct Input {
    /// Test arguments specified in the test attribute.
    args: Punctuated<Expr, Token![,]>,
    /// Test name specified in the test attribute.
    name: Option<LitStr>,
}

impl Parse for Input {
    fn parse(input: syn::parse::ParseStream) -> syn::Result<Self> {
        if input.is_empty() {
            Ok(Input {
                args: Default::default(),
                name: None,
            })
        } else {
            let args: Punctuated<Expr, Token![,]> =
                Punctuated::parse_separated_nonempty_with(input, Expr::parse)?;

            let name = if input.parse::<Token![;]>().is_ok() {
                input.parse::<LitStr>().ok()
            } else {
                None
            };

            Ok(Input { args, name })
        }
    }
}

/// Generates a unique function name for a test case.
/// - If a test name argument is provided (e.g., `#[test(a; xxx)]`), use it as the function name.
/// - Otherwise, generate a function name by concatenating the test parameters with `_`.
fn generate_test_name_with_parameters(
    org_func_name: &str,
    input: &Input,
    prefix: Option<&str>,
) -> String {
    let func_name = org_func_name.to_string();

    if input.args.is_empty() {
        if let Some(prefix) = prefix {
            return format!("{prefix}_{func_name}");
        } else {
            return func_name.to_string();
        }
    }

    let generated = match &input.name {
        Some(name_argument) => name_argument.value(),
        _ => {
            let args = input
                .args
                .iter()
                .filter_map(|expr| {
                    let lit: &Lit = match expr {
                        Expr::Lit(ExprLit { lit, .. }) => lit,
                        _ => {
                            panic!("not supported");
                        }
                    };
                    match lit {
                        Lit::Str(lit_str) => Some(lit_str.value()),
                        Lit::Int(lit_int) => Some(lit_int.to_string()),
                        _ => None,
                    }
                })
                .collect::<Vec<_>>()
                .join("_");

            if let Some(prefix) = prefix {
                return format!("{prefix}_{func_name}_{args}");
            } else {
                return format!("{func_name}_{args}");
            }
        }
    };

    // Check if the generated function name is valid function name.
    if syn::parse_str::<Ident>(&generated).is_err() {
        panic!(
            r#"Test case generation error! The provided test parameters contain
 invalid characters that cannot be used in a function name (function name: {generated}).
 Please specify a valid test name using only letters, numbers, and underscores."#
        );
    }

    generated
}

#[derive(Debug, Eq, PartialEq)]
enum ErrorCrate {
    Eyre,
    AnythingElse,
}

/// Inspects the current function's signature to determine which error crate is being used.
///
/// This function analyzes the return type of the function to detect whether it is using
/// `eyre::Result` or another error result type. It then enables conditional handling based
/// on the error crate in use (e.g., wrapping non-`eyre::Result` types in an `eyre::Result`).
///
/// **Limitation:**
/// Due to the inherent limitations of proc macros, this function can only detect error types
/// when `eyre` is referenced using its fully qualified path (for example, `eyre::Result`).
///
/// For further details and discussion on this limitation, see:
/// https://users.rust-lang.org/t/in-a-proc-macro-attribute-procedural-macro-how-to-get-the-full-typepath-of-some-type/107713/2
fn insepct_error_crate(sig: &Signature) -> ErrorCrate {
    match &sig.output {
        ReturnType::Default => panic!("return type needs to be other than ()"),
        ReturnType::Type(_, ty) => {
            let Type::Path(type_path) = ty.as_ref() else {
                panic!("failed to get return type path");
            };

            let path = &type_path.path;
            match (path.segments.first(), path.segments.last()) {
                (Some(first), Some(last)) => {
                    if first.ident == "eyre" && last.ident == "Result" {
                        ErrorCrate::Eyre
                    } else {
                        ErrorCrate::AnythingElse
                    }
                }
                _ => {
                    panic!("unexpected return type");
                }
            }
        }
    }
}

/// #[test] attribute registers the test function in tanu runner.
/// Without this attribute, tanu can not discover test cases.
#[proc_macro_attribute]
pub fn test(args: TokenStream, input: TokenStream) -> TokenStream {
    let input_args = parse_macro_input!(args as Input);
    let input_fn = parse_macro_input!(input as ItemFn);

    let func_name_inner = &input_fn.sig.ident;
    let test_case = TestCase::from_func_name(&input_args, &func_name_inner.to_string());

    let not_duplicated = TEST_CASES
        .lock()
        .expect("failed to accuire test case lock")
        .insert(test_case.clone());
    if !not_duplicated {
        panic!(
            r#"tanu does not yet support registering test with the exactly same signature.
 please check the name of this function "{func_name_inner}" and try again."#
        );
    }

    let func_name = Ident::new(&test_case.func_name, Span::call_site());
    let args = input_args.args.to_token_stream();

    // tanu internally relies on the `eyre` and `color-eyre` crates for error handling.
    // since `tanu::Runner` expects test functions to return an `eyre::Result`, the macro
    // generates two types of code.
    //
    // - If a test function explicitly returns `eyre::Result`, the macro will generate
    //   a function that also returns `eyre::Result` without modification.
    //
    // - If the test function returns another result type (e.g., `anyhow::Result`),
    //   the macro will automatically wrap the return value in an `eyre::Result`.
    let error_crate = insepct_error_crate(&input_fn.sig);
    let output = if error_crate == ErrorCrate::Eyre {
        quote! {
            #input_fn
            pub(crate) async fn #func_name() -> tanu::eyre::Result<()> {
                #func_name_inner(#args).await
            }
        }
    } else {
        quote! {
            #input_fn
            pub(crate) async fn #func_name() -> tanu::eyre::Result<()> {
                #func_name_inner(#args).await.map_err(|e| tanu::eyre::eyre!(Box::new(e)))
            }
        }
    };

    output.into()
}

fn find_crate_root() -> eyre::Result<PathBuf> {
    let dir = std::env::var("CARGO_MANIFEST_DIR")?;
    Ok(dir.into())
}

fn discover_tests() -> eyre::Result<Vec<TestModule>> {
    let root = find_crate_root()?;

    // Look up all rust source files.
    let source_paths: Vec<_> = WalkDir::new(root)
        .into_iter()
        .filter_map(|entry| {
            let path = entry.ok()?.into_path();
            let ext = path.extension()?;
            if ext.eq_ignore_ascii_case("rs") {
                Some(path)
            } else {
                None
            }
        })
        .collect();

    let mut test_modules = Vec::<TestModule>::new();
    for source_path in source_paths {
        let mut source_file = std::fs::File::open(&source_path)
            .wrap_err_with(|| format!("could not open file: {}", source_path.display()))?;
        let mut code = String::new();
        source_file.read_to_string(&mut code)?;

        let file = syn::parse_file(&code)?;
        test_modules.extend(extract_module_and_test(
            source_path
                .file_stem()
                .ok_or_eyre("invalid source file name")?
                .to_str()
                .ok_or_eyre("invalid source file name")?,
            file,
        ));
    }

    Ok(test_modules)
}

/// Test the function has #[tanu::test] attribute.
fn has_test_attribute(path: &syn::Path) -> bool {
    // The function has #[test].
    let has_test = path.is_ident("test");
    // The function has #[tanu::test].
    let has_tanu_test = match (path.segments.first(), path.segments.last()) {
        (Some(first), Some(last)) => {
            path.segments.len() == 2 && first.ident == "tanu" && last.ident == "test"
        }
        _ => false,
    };

    has_test || has_tanu_test
}

fn extract_module_and_test(module: &str, input: File) -> Vec<TestModule> {
    let mut test_modules = Vec::new();
    for item in input.items {
        if let Item::Fn(item_fn) = item {
            let mut is_test = false;
            let mut test_cases = Vec::new();
            for attr in item_fn.attrs {
                if has_test_attribute(attr.path()) {
                    is_test = true;

                    match &attr.meta {
                        // There is no arguments in test attribute which is #[test]
                        Meta::Path(_path) => {
                            let test_case = TestCase {
                                func_name: format!("tanu_{}", item_fn.sig.ident),
                                test_name: format!("tanu_{}", item_fn.sig.ident),
                            };
                            test_cases.push(test_case);
                        }
                        // There is arguments to parse from test attribute which is like #[test(xxx, ...)]
                        Meta::List(_list) => match attr.parse_args_with(Input::parse) {
                            Ok(test_case_token) => {
                                let test_case = TestCase::from_func_name(
                                    &test_case_token,
                                    &item_fn.sig.ident.to_string(),
                                );
                                test_cases.push(test_case);
                            }
                            Err(e) => {
                                eprintln!("failed to parse attributes in #[test]: {e:#}");
                            }
                        },
                        _ => {}
                    }
                }
            }
            if is_test {
                test_modules.push(TestModule {
                    module: module.to_owned(),
                    func_name: item_fn.sig.ident.to_string(),
                    test_cases,
                });
            }
        }
    }

    test_modules
}

#[proc_macro_attribute]
pub fn main(_args: TokenStream, input: TokenStream) -> TokenStream {
    let main_fn = parse_macro_input!(input as ItemFn);

    let test_modules = discover_tests().expect("failed to discover test cases");
    let test_modules: HashMap<String, String> = test_modules
        .iter()
        .flat_map(|module| {
            let module_name = module.module.clone();
            module.test_cases.iter().map(move |test_case| {
                (
                    test_case.func_name.clone(),
                    if module_name == "main" {
                        "crate".into()
                    } else {
                        module_name.clone()
                    },
                )
            })
        })
        .collect();

    let (test_mods, test_names, func_names): (Vec<_>, Vec<_>, Vec<_>) = TEST_CASES
        .lock()
        .expect("failed to accuire test case lock")
        .iter()
        .map(|f| {
            let test_module = test_modules.get(&f.func_name).expect("module not found");
            (
                Ident::new(test_module, Span::call_site()),
                f.test_name.clone(),
                Ident::new(&f.func_name, Span::call_site()),
            )
        })
        .multiunzip();

    let output = quote! {
        fn run() -> tanu::Runner {
            let mut runner = tanu::Runner::new();
            #(
            runner.add_test(#test_names, stringify!(#test_mods), Box::new(|| Box::pin(#test_mods::#func_names())));
            )*
            runner
        }

        #main_fn
    };

    output.into()
}

#[cfg(test)]
mod test {
    use super::ErrorCrate;
    use test_case::test_case;

    #[test_case("test" => true; "test")]
    #[test_case("tanu::test" => true; "tanu_test")]
    #[test_case("tanu::foo::test" => false; "not_tanu_test")]
    #[test_case("foo::test" => false; "also_not_tanu_test")]
    fn has_test_attribute(s: &str) -> bool {
        let path: syn::Path = syn::parse_str(s).expect("Failed to parse path");
        super::has_test_attribute(&path)
    }

    #[test_case("fn foo() -> eyre::Result" => ErrorCrate::Eyre; "eyre")]
    #[test_case("fn foo() -> anyhow::Result" => ErrorCrate::AnythingElse; "anyhow")]
    #[test_case("fn foo() -> miette::Result" => ErrorCrate::AnythingElse; "miette")]
    #[test_case("fn foo() -> Result" => ErrorCrate::AnythingElse; "std_result")]
    fn insepct_error_crate(s: &str) -> ErrorCrate {
        let sig: syn::Signature = syn::parse_str(s).expect("failed to parse function signature");
        super::insepct_error_crate(&sig)
    }
}
