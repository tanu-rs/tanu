{"config":{"lang":["en"],"separator":"[\\s\\-,:!=\\[\\]()\"`/]+|\\.(?!\\d)|&[lg]t;|(?!\\b)(?=[A-Z][a-z])","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"Welcome","text":"<p>tanu: high-performance, async-friendly and ergonomic WebAPI testing framework for Rust</p> <p> </p>"},{"location":"#motivation","title":"Motivation","text":"<p>As a long time backend engineer, I have always been passionate about building reliable and efficient systems. When working with WebAPIs, ensuring correctness, stability, and performance is crucial, yet I often found existing testing frameworks lacking in speed, flexibility, or Rust-native support. This led me to create a WebAPI testing framework in Rust.</p> <p>While some WebAPI testing tools exist for Rust, they often lack ergonomics, are too low-level, or don't integrate well with modern Rust web frameworks. My goal was to create a framework that is:</p> <ul> <li>Fast and lightweight \u2013 Leveraging Rust\u2019s zero-cost abstractions to minimize unnecessary overhead.</li> <li>Type-safe and ergonomic \u2013 Taking advantage of Rust\u2019s strong type system to prevent common errors at compile time.</li> <li>Easily extensible \u2013 Allowing developers to integrate custom assertions, mocking, and performance metrics seamlessly.</li> <li>Concurrency and async-friendly \u2013 Supporting asynchronous requests and concurrent execution to test APIs efficiently.</li> </ul> <p>I tried multiple solutions in the past but encountered significant limitations:</p> <ul> <li>Postman - Postman is a great tool but not designed for API end-to-end testing. You need a GUI and have to write assertions in JavaScript, which results in massive JSON files that become difficult to manage.</li> <li>Playwright - Playwright is an excellent framework for web end-to-end testing. While it does support API testing, I wanted to use the same language for both API implementation and tests, which Playwright does not offer.</li> <li>Rust Standard Test Framework - I attempted multiple times to write API tests using <code>#[test]</code>, along with tokio, test-case, and reqwest crates. While functional, this approach lacked structure and ergonomics for writing effective tests at scale. I wanted a dedicated framework to simplify and streamline the process.</li> </ul>"},{"location":"#writing-tests-with-tanu","title":"Writing Tests with Tanu","text":"<p>Writing API tests with tanu is designed to be intuitive and ergonomic. Here's what a typical test looks like:</p> <pre><code>use tanu::{check, check_eq, eyre, http::Client};\n\n#[tanu::test]\nasync fn get_user_profile() -&gt; eyre::Result&lt;()&gt; {\n    let client = Client::new();\n\n    // Make HTTP request\n    let response = client\n        .get(\"https://api.example.com/users/123\")\n        .header(\"authorization\", \"Bearer token123\")\n        .send()\n        .await?;\n\n    // Verify response\n    check!(response.status().is_success(), \"Expected successful response\");\n\n    // Parse and validate JSON\n    let user: serde_json::Value = response.json().await?;\n    check_eq!(123, user[\"id\"].as_i64().unwrap());\n    check_eq!(\"John Doe\", user[\"name\"].as_str().unwrap());\n\n    Ok(())\n}\n\n// Parameterized tests for testing multiple scenarios\n#[tanu::test(200)]\n#[tanu::test(404)]\n#[tanu::test(500)]\nasync fn test_status_codes(expected_status: u16) -&gt; eyre::Result&lt;()&gt; {\n    let client = Client::new();\n    let response = client\n        .get(&amp;format!(\"https://httpbin.org/status/{expected_status}\"))\n        .send()\n        .await?;\n\n    check_eq!(expected_status, response.status().as_u16());\n    Ok(())\n}\n\n#[tanu::main]\n#[tokio::main]\nasync fn main() -&gt; eyre::Result&lt;()&gt; {\n    let runner = run();\n    let app = tanu::App::new();\n    app.run(runner).await?;\n    Ok(())\n}\n</code></pre>"},{"location":"#key-features-highlighted","title":"Key Features Highlighted:","text":"<ul> <li>Simple and Clean: Tests look like regular Rust functions with the <code>#[tanu::test]</code> attribute</li> <li>Async/Await Native: Full support for async operations without boilerplate</li> <li>Type-Safe: Leverage Rust's type system for robust API testing</li> <li>Ergonomic Assertions: Use <code>check!</code>, <code>check_eq!</code>, and other assertion macros for clear test validation</li> <li>Parameterized Testing: Test multiple scenarios with different inputs using multiple <code>#[tanu::test(param)]</code> attributes</li> <li>Serial Execution Control: Run tests sequentially when needed with <code>#[tanu::test(serial)]</code> or grouped serial execution</li> <li>Built-in HTTP Client: No need to set up reqwest or other HTTP clients manually</li> <li>Error Handling: Clean error propagation with <code>eyre::Result</code></li> </ul>"},{"location":"#screenshots","title":"Screenshots","text":""},{"location":"#contributors","title":"Contributors","text":"<p>Thanks to all the amazing people who have contributed to making tanu better! Every contribution, big or small, helps build a more robust and feature-rich testing framework for the Rust community \u2728</p> <p> </p> <p>Made with contrib.rocks.</p>"},{"location":"#acknowledgments","title":"Acknowledgments","text":"<p>We're grateful to our sponsors who support the development of tanu:</p> <sub>yuk1ty</sub>  \ud83d\udc36  <sub>2323-code</sub>  \ud83e\udd69  <p>Your support helps make tanu better for everyone. Thank you! \ud83d\ude4f</p>"},{"location":"#license","title":"License","text":"<p>This project is licensed under the Apache License 2.0 - see the LICENSE file for details.</p> <p>The Apache License 2.0 is a permissive open source license that allows you to: - Use the software for any purpose - Distribute it - Modify it - Distribute modified versions - Place warranty</p> <p>For more information about the Apache License 2.0, visit: http://www.apache.org/licenses/LICENSE-2.0</p>"},{"location":"assertion/","title":"Assertions","text":"<p>Tanu provides a comprehensive assertion system designed specifically for WebAPI testing. The assertion macros follow similar signatures to Rust's standard <code>assert!</code> macros but are tailored for testing environments with enhanced error reporting and colored output.</p>"},{"location":"assertion/#key-features","title":"Key Features","text":"<ul> <li>Error-based instead of panic-based: Returns <code>eyre::Result</code> instead of panicking</li> <li>Colored output: Uses <code>pretty_assertions</code> for beautiful diff visualization</li> <li>Event publishing: Publishes test results to the tanu runner for reporting</li> <li>Async-friendly: Works seamlessly with async test functions</li> </ul>"},{"location":"assertion/#available-macros","title":"Available Macros","text":""},{"location":"assertion/#check","title":"<code>check!</code>","text":"<p>Basic assertion macro that validates a boolean condition.</p> <pre><code>use tanu::check;\n\n#[tanu::test]\nasync fn basic_check() -&gt; eyre::Result&lt;()&gt; {\n    check!(true);\n    check!(2 + 2 == 4);\n    check!(response.status().is_success(), \"Expected successful response\");\n    Ok(())\n}\n</code></pre> <p>Signatures: - <code>check!(condition)</code> - Simple boolean check - <code>check!(condition, message, args...)</code> - With custom error message</p>"},{"location":"assertion/#check_eq","title":"<code>check_eq!</code>","text":"<p>Asserts that two values are equal, with pretty-printed diff output for mismatches.</p> <pre><code>use tanu::check_eq;\n\n#[tanu::test]\nasync fn equality_check() -&gt; eyre::Result&lt;()&gt; {\n    check_eq!(200, response.status().as_u16());\n    check_eq!(\"application/json\", response.headers().get(\"content-type\"));\n    check_eq!(expected_payload, actual_payload, \"Response payload mismatch\");\n    Ok(())\n}\n</code></pre> <p>Signatures: - <code>check_eq!(left, right)</code> - Basic equality check - <code>check_eq!(left, right, message, args...)</code> - With custom error message</p>"},{"location":"assertion/#check_ne","title":"<code>check_ne!</code>","text":"<p>Asserts that two values are not equal.</p> <pre><code>use tanu::check_ne;\n\n#[tanu::test]\nasync fn inequality_check() -&gt; eyre::Result&lt;()&gt; {\n    check_ne!(404, response.status().as_u16());\n    check_ne!(\"\", response.body());\n    Ok(())\n}\n</code></pre> <p>Signatures: - <code>check_ne!(left, right)</code> - Basic inequality check - <code>check_ne!(left, right, message, args...)</code> - With custom error message</p>"},{"location":"assertion/#check_str_eq","title":"<code>check_str_eq!</code>","text":"<p>Specialized string equality assertion with enhanced string comparison visualization.</p> <pre><code>use tanu::check_str_eq;\n\n#[tanu::test]\nasync fn string_check() -&gt; eyre::Result&lt;()&gt; {\n    check_str_eq!(\"expected\", actual_string);\n    check_str_eq!(expected_json, response.text().await?, \"JSON response mismatch\");\n    Ok(())\n}\n</code></pre> <p>Signatures: - <code>check_str_eq!(left, right)</code> - Basic string equality check - <code>check_str_eq!(left, right, message, args...)</code> - With custom error message</p>"},{"location":"assertion/#key-differences-from-standard-assert","title":"Key Differences from Standard <code>assert!</code>","text":"Feature Standard <code>assert!</code> Tanu <code>check!</code> Error handling Panics on failure Returns <code>eyre::Result</code> Output format Basic text Colored with <code>pretty_assertions</code> Integration Standalone Publishes events to tanu runner Async support Limited Full async/await support Macro naming <code>assert!</code>, <code>assert_eq!</code>, <code>assert_ne!</code> <code>check!</code>, <code>check_eq!</code>, <code>check_ne!</code>, <code>check_str_eq!</code>"},{"location":"assertion/#error-handling","title":"Error Handling","text":"<p>All assertion macros return <code>eyre::Result</code> types, making them compatible with async test functions that return <code>Result</code> types. When an assertion fails:</p> <ol> <li>An error event is published to the tanu runner</li> <li>An <code>eyre::Report</code> is generated with detailed context</li> <li>The error is propagated up the call stack</li> <li>Tanu displays colored backtraces and error information</li> </ol>"},{"location":"assertion/#examples","title":"Examples","text":""},{"location":"assertion/#http-response-testing","title":"HTTP Response Testing","text":"<pre><code>use tanu::{check, check_eq, check_ne, eyre, http::Client};\n\n#[tanu::test]\nasync fn api_test() -&gt; eyre::Result&lt;()&gt; {\n    let client = Client::new();\n    let response = client\n        .get(\"https://api.example.com/users\")\n        .send()\n        .await?;\n\n    // Check status code\n    check!(response.status().is_success(), \"API request failed\");\n    check_eq!(200, response.status().as_u16());\n\n    // Check headers\n    check_ne!(\"\", response.headers().get(\"content-type\").unwrap());\n\n    // Check response body\n    let users: Vec&lt;User&gt; = response.json().await?;\n    check!(!users.is_empty(), \"Expected non-empty user list\");\n\n    Ok(())\n}\n</code></pre>"},{"location":"assertion/#json-response-validation","title":"JSON Response Validation","text":"<pre><code>use tanu::{check_eq, check_str_eq, eyre, http::Client};\nuse serde_json::Value;\n\n#[tanu::test]\nasync fn json_validation() -&gt; eyre::Result&lt;()&gt; {\n    let client = Client::new();\n    let response = client\n        .get(\"https://api.example.com/config\")\n        .send()\n        .await?;\n\n    let json: Value = response.json().await?;\n\n    check_eq!(\"v1.0\", json[\"version\"].as_str().unwrap());\n    check_str_eq!(\"production\", json[\"environment\"].as_str().unwrap());\n\n    Ok(())\n}\n</code></pre>"},{"location":"assertion/#best-practices","title":"Best Practices","text":"<ol> <li> <p>Use descriptive messages: Always provide context for assertion failures    <pre><code>check!(response.status().is_success(), \"Failed to authenticate user\");\n</code></pre></p> </li> <li> <p>Choose the right assertion: Use <code>check_str_eq!</code> for string comparisons to get better diff output    <pre><code>// Good\ncheck_str_eq!(expected_json, actual_json);\n\n// Less helpful output\ncheck_eq!(expected_json, actual_json);\n</code></pre></p> </li> <li> <p>Combine with HTTP utilities: Leverage tanu's HTTP client for comprehensive API testing    <pre><code>let response = client.post(\"/api/login\")\n    .json(&amp;credentials)\n    .send()\n    .await?;\n\ncheck!(response.status().is_success(), \"Login failed\");\n</code></pre></p> </li> <li> <p>Handle async properly: All assertions work seamlessly in async contexts    <pre><code>#[tanu::test]\nasync fn async_test() -&gt; eyre::Result&lt;()&gt; {\n    let result = some_async_operation().await?;\n    check!(result.is_valid());\n    Ok(())\n}\n</code></pre></p> </li> </ol>"},{"location":"assertion/#error-output","title":"Error Output","text":"<p>When assertions fail, tanu provides rich error information:</p> <pre><code>check failed: `(left == right)`: Expected status code 200\n\n   left: 404\n  right: 200\n\nError: check failed: `(left == right)`: Expected status code 200\n</code></pre> <p>For string comparisons, you get detailed diff output highlighting the differences between expected and actual values.</p>"},{"location":"attribute/","title":"<code>#[tanu::test]</code> Attribute","text":"<p>The <code>#[tanu::test]</code> attribute is used to mark functions as test functions in the Tanu framework. When a function is annotated with this attribute, it will be executed as part of the test suite.</p>"},{"location":"attribute/#usage","title":"Usage","text":"<p>To use the <code>#[tanu::test]</code> attribute, simply add it above the function definition:</p> <pre><code>use tanu::check_eq;\n\n#[tanu::test]\nasync fn my_test_function() -&gt; eyre::Result&lt;()&gt; {\n    let result = 2 + 2;\n    check_eq!(result, 4);\n    Ok(())\n}\n</code></pre> <p>Notes * The #[tanu::test] attribute can only be applied to \"async\" functions. * Functions marked with #[tanu::test] should not take any arguments and should not return any values. * The tanu framework will automatically discover and run all functions marked with the <code>#[tanu::test]</code> attribute when the test suite is executed.</p>"},{"location":"attribute/#parameterized-tests","title":"Parameterized Tests","text":"<p><code>#[tanu::test]</code> attribute is inspired by test_case crate where you can easily parameterize test case by providing parameters in the attribute body as follows.</p> <pre><code>use tanu::check_eq;\n\n#[tanu::test(10, 10, 20)]\n#[tanu::test(20, 20, 40)]\nasync fn my_test_function(a: u32, b: u32, expected: u32) -&gt; eyre::Result&lt;()&gt; {\n    let result = a + b;\n    check_eq!(result, expected);\n    Ok(())\n}\n</code></pre> <p>If you run a parameterized test, the test name will be automatically generated by concatenating the stringified parameters, resulting in <code>my_test_function_10_10_20</code>.</p> <p>Sometimes parameters can't be strigified, in such case, tanu refuse to compile the code. In such cases, tanu refuses to compile the code. If that happens, you can specify your desired name rather than the auto-generated one. Note that a test name is delimited by <code>;</code> from the parameters.</p> <pre><code>use tanu::check_eq;\n\n#[tanu::test(10, 10, 20; \"add_10_and_10_equal_20\")]\n#[tanu::test(20, 20, 40; \"add_20_and_20_equal_40\")]\nasync fn my_test_function(a: u32, b: u32, expected: u32) -&gt; eyre::Result&lt;()&gt; {\n    let result = a + b;\n    check_eq!(result, expected);\n    Ok(())\n}\n</code></pre>"},{"location":"attribute/#serial-execution","title":"Serial Execution","text":"<p>By default, Tanu runs tests in parallel for better performance. However, some tests need to run sequentially, such as tests that:</p> <ul> <li>Share mutable state (databases, files, environment variables)</li> <li>Modify global resources</li> <li>Have ordering dependencies</li> </ul> <p>The <code>serial</code> attribute allows you to control test execution order.</p>"},{"location":"attribute/#basic-serial-execution","title":"Basic Serial Execution","text":"<p>Use <code>serial</code> to run tests sequentially with all other serial tests:</p> <pre><code>#[tanu::test(serial)]\nasync fn database_setup() -&gt; eyre::Result&lt;()&gt; {\n    // This test runs serially with all other serial tests\n    Ok(())\n}\n\n#[tanu::test(serial)]\nasync fn database_cleanup() -&gt; eyre::Result&lt;()&gt; {\n    // Runs after database_setup completes\n    Ok(())\n}\n</code></pre>"},{"location":"attribute/#named-serial-groups","title":"Named Serial Groups","text":"<p>Create named groups to isolate serial execution. Tests in different groups can run in parallel:</p> <pre><code>#[tanu::test(serial = \"database\")]\nasync fn db_write() -&gt; eyre::Result&lt;()&gt; {\n    // Serializes only with other \"database\" group tests\n    Ok(())\n}\n\n#[tanu::test(serial = \"database\")]\nasync fn db_read() -&gt; eyre::Result&lt;()&gt; {\n    // Runs after db_write within the database group\n    Ok(())\n}\n\n#[tanu::test(serial = \"cache\")]\nasync fn cache_write() -&gt; eyre::Result&lt;()&gt; {\n    // Can run in parallel with database group\n    Ok(())\n}\n</code></pre>"},{"location":"attribute/#serial-with-parameters","title":"Serial with Parameters","text":"<p>The <code>serial</code> attribute can be combined with parameterized tests. The <code>serial</code> keyword can appear anywhere in the attribute arguments:</p> <pre><code>// Serial before parameters\n#[tanu::test(serial, 200)]\n#[tanu::test(serial, 404)]\nasync fn test_status_codes(code: u16) -&gt; eyre::Result&lt;()&gt; {\n    Ok(())\n}\n\n// Serial after parameters\n#[tanu::test(1, 2, serial)]\n#[tanu::test(3, 4, serial)]\nasync fn test_addition(a: i32, b: i32) -&gt; eyre::Result&lt;()&gt; {\n    Ok(())\n}\n\n// Named groups with parameters\n#[tanu::test(serial = \"api\", 200)]\n#[tanu::test(serial = \"api\", 404)]\nasync fn test_api_codes(code: u16) -&gt; eyre::Result&lt;()&gt; {\n    Ok(())\n}\n</code></pre>"},{"location":"attribute/#key-points","title":"Key Points","text":"<ul> <li>Project-scoped: Serial groups are scoped per project. Same group name in different projects won't interfere.</li> <li>Concurrency control: Serial tests acquire their group mutex before the global concurrency semaphore, preventing resource blocking.</li> <li>Minimal lock scope: The serial lock only covers test execution, not setup, teardown, or retry logic.</li> <li>Performance: Non-serial tests and different serial groups run in parallel for optimal performance.</li> </ul>"},{"location":"best-practices/","title":"Best Practices","text":"<p>tags:   - Testing   - HTTP   - Configuration</p> <p>This guide covers best practices for writing effective API tests with tanu, based on real-world experience and established patterns.</p>"},{"location":"best-practices/#test-organization","title":"Test Organization","text":""},{"location":"best-practices/#use-descriptive-test-names","title":"Use Descriptive Test Names","text":"<p>Choose test names that clearly describe what is being tested:</p> <pre><code>// Good\n#[tanu::test]\nasync fn get_user_returns_valid_profile_data() -&gt; eyre::Result&lt;()&gt; { ... }\n\n#[tanu::test]\nasync fn create_user_with_invalid_email_returns_400() -&gt; eyre::Result&lt;()&gt; { ... }\n\n// Less clear\n#[tanu::test]\nasync fn test_user() -&gt; eyre::Result&lt;()&gt; { ... }\n\n#[tanu::test]\nasync fn user_test_2() -&gt; eyre::Result&lt;()&gt; { ... }\n</code></pre>"},{"location":"best-practices/#group-related-tests-in-modules","title":"Group Related Tests in Modules","text":"<p>Organize tests by feature or endpoint:</p> <pre><code>// src/tests/user.rs\nmod user {\n    #[tanu::test]\n    async fn create_user_success() -&gt; eyre::Result&lt;()&gt; { ... }\n\n    #[tanu::test]\n    async fn get_user_profile() -&gt; eyre::Result&lt;()&gt; { ... }\n\n    #[tanu::test]\n    async fn update_user_profile() -&gt; eyre::Result&lt;()&gt; { ... }\n}\n\n// src/tests/auth.rs\nmod auth {\n    #[tanu::test]\n    async fn login_with_valid_credentials() -&gt; eyre::Result&lt;()&gt; { ... }\n\n    #[tanu::test]\n    async fn login_with_invalid_credentials() -&gt; eyre::Result&lt;()&gt; { ... }\n}\n</code></pre>"},{"location":"best-practices/#http-best-practices","title":"HTTP Best Practices","text":""},{"location":"best-practices/#check-response-headers-with-original-casing","title":"Check Response Headers with Original Casing","text":"<p>When validating response headers, use the casing returned by the server:</p> <pre><code>let response: HeadersResponse = res.json().await?;\n\n// Server returns headers with original casing\ncheck!(response.headers.contains_key(\"Content-Type\"));\ncheck!(response.headers.contains_key(\"X-Custom-Header\"));\n</code></pre>"},{"location":"best-practices/#handle-errors-gracefully","title":"Handle Errors Gracefully","text":"<p>Always handle potential HTTP errors:</p> <pre><code>#[tanu::test]\nasync fn robust_api_test() -&gt; eyre::Result&lt;()&gt; {\n    let client = Client::new();\n\n    let response = client\n        .get(\"https://api.example.com/users/123\")\n        .send()\n        .await?;\n\n    // Check status before processing response\n    check!(response.status().is_success(), \n           \"Expected successful response, got: {}\", response.status());\n\n    // Handle potential JSON parsing errors\n    let user: serde_json::Value = response.json().await\n        .map_err(|e| eyre::eyre!(\"Failed to parse JSON response: {}\", e))?;\n\n    Ok(())\n}\n</code></pre>"},{"location":"best-practices/#parameterized-testing","title":"Parameterized Testing","text":""},{"location":"best-practices/#use-parameterized-tests-for-similar-scenarios","title":"Use Parameterized Tests for Similar Scenarios","text":"<p>Instead of duplicating test logic, use parameterized tests:</p> <pre><code>// Good - Single test function with multiple parameters\n#[tanu::test(200)]\n#[tanu::test(404)]\n#[tanu::test(500)]\nasync fn test_status_endpoints(status_code: u16) -&gt; eyre::Result&lt;()&gt; {\n    let client = Client::new();\n    let response = client\n        .get(&amp;format!(\"https://httpbin.org/status/{status_code}\"))\n        .send()\n        .await?;\n\n    check_eq!(status_code, response.status().as_u16());\n    Ok(())\n}\n\n// Less efficient - Separate functions for each test case\n#[tanu::test]\nasync fn test_200_status() -&gt; eyre::Result&lt;()&gt; { ... }\n\n#[tanu::test]\nasync fn test_404_status() -&gt; eyre::Result&lt;()&gt; { ... }\n\n#[tanu::test]\nasync fn test_500_status() -&gt; eyre::Result&lt;()&gt; { ... }\n</code></pre>"},{"location":"best-practices/#choose-meaningful-parameter-values","title":"Choose Meaningful Parameter Values","text":"<p>Select parameter values that represent real-world scenarios:</p> <pre><code>// Good - Realistic delay values\n#[tanu::test(1)]\n#[tanu::test(2)]\n#[tanu::test(5)]\nasync fn test_api_timeout_handling(delay_seconds: u64) -&gt; eyre::Result&lt;()&gt; { ... }\n\n// Good - Common HTTP status codes\n#[tanu::test(400)]  // Bad Request\n#[tanu::test(401)]  // Unauthorized  \n#[tanu::test(403)]  // Forbidden\n#[tanu::test(404)]  // Not Found\nasync fn test_error_responses(status_code: u16) -&gt; eyre::Result&lt;()&gt; { ... }\n</code></pre>"},{"location":"best-practices/#assertions","title":"Assertions","text":""},{"location":"best-practices/#use-specific-assertion-macros","title":"Use Specific Assertion Macros","text":"<p>Choose the most appropriate assertion macro for better error messages:</p> <pre><code>// Good - Specific assertions\ncheck_eq!(expected_id, user[\"id\"].as_i64().unwrap());\ncheck_ne!(0, response.headers().len());\ncheck!(response.status().is_success());\n\n// Less informative\ncheck!(user[\"id\"].as_i64().unwrap() == expected_id);\ncheck!(response.headers().len() &gt; 0);\ncheck!(response.status().as_u16() &gt;= 200 &amp;&amp; response.status().as_u16() &lt; 300);\n</code></pre>"},{"location":"best-practices/#provide-descriptive-error-messages","title":"Provide Descriptive Error Messages","text":"<p>Add context to your assertions:</p> <pre><code>check!(response.status().is_success(), \n       \"API should return success status, got: {} - {}\", \n       response.status(), \n       response.text().await?);\n\ncheck_eq!(expected_name, user[\"name\"].as_str().unwrap(),\n          \"User name should match expected value\");\n</code></pre>"},{"location":"best-practices/#validate-response-structure","title":"Validate Response Structure","text":"<p>Don't just check status codes - validate the actual response data:</p> <pre><code>#[tanu::test]\nasync fn get_user_returns_complete_profile() -&gt; eyre::Result&lt;()&gt; {\n    let response = client.get(\"/users/123\").send().await?;\n    check!(response.status().is_success());\n\n    let user: serde_json::Value = response.json().await?;\n\n    // Validate required fields exist\n    check!(user[\"id\"].is_number(), \"User ID should be a number\");\n    check!(user[\"name\"].is_string(), \"User name should be a string\");\n    check!(user[\"email\"].is_string(), \"User email should be a string\");\n    check!(user[\"created_at\"].is_string(), \"Created date should be present\");\n\n    // Validate field values\n    check_eq!(123, user[\"id\"].as_i64().unwrap());\n    check!(!user[\"name\"].as_str().unwrap().is_empty(), \"Name should not be empty\");\n\n    Ok(())\n}\n</code></pre>"},{"location":"best-practices/#use-serde-for-type-safe-response-validation","title":"Use Serde for Type-Safe Response Validation","text":"<p>Instead of manually parsing JSON, define response structures with serde for better type safety and automatic validation:</p> <pre><code>use serde::Deserialize;\n\n#[derive(Debug, Deserialize)]\nstruct User {\n    id: i64,\n    name: String,\n    email: String,\n    verified: bool,\n    created_at: String,\n}\n\n#[derive(Debug, Deserialize)]\nstruct CreateUserResponse {\n    user: User,\n    message: String,\n}\n\n#[tanu::test]\nasync fn create_user_with_serde_validation() -&gt; eyre::Result&lt;()&gt; {\n    let user_data = serde_json::json!({\n        \"name\": \"John Doe\",\n        \"email\": \"john@example.com\"\n    });\n\n    let response = client\n        .post(\"/users\")\n        .json(&amp;user_data)\n        .send()\n        .await?;\n\n    check!(response.status().is_success());\n\n    // Serde automatically validates the response structure\n    let create_response: CreateUserResponse = response.json().await\n        .map_err(|e| eyre::eyre!(\"Failed to parse response: {}\", e))?;\n\n    // Type-safe field access\n    check_eq!(\"John Doe\", create_response.user.name);\n    check_eq!(\"john@example.com\", create_response.user.email);\n    check!(!create_response.user.verified); // New users start unverified\n    check!(!create_response.message.is_empty());\n\n    Ok(())\n}\n</code></pre> <p>Benefits of using serde: - Compile-time safety: Field names and types are checked at compile time - Automatic validation: Serde will fail if required fields are missing or have wrong types - Better error messages: Clear errors when deserialization fails - Documentation: Struct definitions serve as API documentation - Refactoring safety: Changes to field names are caught by the compiler</p> <p>Optional fields and error handling: <pre><code>#[derive(Debug, Deserialize)]\nstruct UserProfile {\n    id: i64,\n    name: String,\n    email: String,\n    #[serde(default)]\n    avatar_url: Option&lt;String&gt;,\n    #[serde(rename = \"created_at\")]\n    created_date: String,\n}\n\n#[tanu::test]\nasync fn handle_optional_fields_with_serde() -&gt; eyre::Result&lt;()&gt; {\n    let response = client.get(\"/users/123\").send().await?;\n    check!(response.status().is_success());\n\n    let user: UserProfile = response.json().await?;\n\n    // Required fields are guaranteed to exist\n    check_eq!(123, user.id);\n    check!(!user.name.is_empty());\n\n    // Optional fields can be safely checked\n    if let Some(avatar) = user.avatar_url {\n        check!(avatar.starts_with(\"https://\"));\n    }\n\n    Ok(())\n}\n</code></pre></p>"},{"location":"best-practices/#configuration-management","title":"Configuration Management","text":""},{"location":"best-practices/#use-environment-specific-configurations","title":"Use Environment-Specific Configurations","text":"<p>Create separate configurations for different environments:</p> <pre><code># tanu.toml\n[[projects]]\nname = \"local\"\nbase_url = \"http://localhost:8080\"\ntimeout = 5000\n\n[[projects]]\nname = \"staging\"\nbase_url = \"https://staging.api.example.com\"\ntimeout = 10000\nretry.count = 2\n\n[[projects]]\nname = \"production\" \nbase_url = \"https://api.example.com\"\ntimeout = 15000\nretry.count = 3\nretry.factor = 2.0\n</code></pre>"},{"location":"best-practices/#ignore-flaky-or-slow-tests-appropriately","title":"Ignore Flaky or Slow Tests Appropriately","text":"<p>Use test_ignore for tests that shouldn't run in certain environments:</p> <pre><code>[[projects]]\nname = \"ci\"\ntest_ignore = [\n    \"slow_integration_test\",\n    \"external_dependency_test\",\n    \"load_test\"\n]\n</code></pre>"},{"location":"best-practices/#performance-considerations","title":"Performance Considerations","text":""},{"location":"best-practices/#minimize-test-dependencies","title":"Minimize Test Dependencies","text":"<p>Keep tests isolated and avoid dependencies between test cases:</p> <pre><code>// Good - Each test is independent\n#[tanu::test]\nasync fn create_user_test() -&gt; eyre::Result&lt;()&gt; {\n    // Create test data\n    // Run test\n    // Clean up (if needed)\n    Ok(())\n}\n\n// Avoid - Tests depending on each other\n#[tanu::test]\nasync fn create_user_first() -&gt; eyre::Result&lt;()&gt; { ... }\n\n#[tanu::test]\nasync fn update_user_created_above() -&gt; eyre::Result&lt;()&gt; {\n    // This test depends on the previous test\n    Ok(())\n}\n</code></pre>"},{"location":"best-practices/#use-serial-execution-when-needed","title":"Use Serial Execution When Needed","text":"<p>By default, Tanu runs tests in parallel for maximum performance. However, some tests need to run sequentially. Use the <code>serial</code> attribute judiciously:</p> <p>When to use serial tests:</p> <ol> <li>Shared mutable state: Tests that modify shared resources (databases, files, environment variables)</li> <li>Global state: Tests that rely on or modify global state</li> <li>Resource constraints: Tests that exhaust limited resources (ports, file handles)</li> <li>External dependencies: Tests interacting with external systems that don't support concurrency</li> </ol> <pre><code>// Good - Serial for database tests that share state\n#[tanu::test(serial = \"database\")]\nasync fn test_database_migration() -&gt; eyre::Result&lt;()&gt; {\n    // Modifies shared database schema\n    Ok(())\n}\n\n#[tanu::test(serial = \"database\")]\nasync fn test_database_seeding() -&gt; eyre::Result&lt;()&gt; {\n    // Depends on clean database state\n    Ok(())\n}\n\n// Good - Parallel for independent API tests\n#[tanu::test]\nasync fn test_get_user_endpoint() -&gt; eyre::Result&lt;()&gt; {\n    // Read-only, no shared state\n    Ok(())\n}\n</code></pre> <p>Best practices for serial tests:</p> <ul> <li>Use named groups: Organize serial tests into logical groups (<code>serial = \"database\"</code>, <code>serial = \"cache\"</code>) so different groups can run in parallel</li> <li>Keep them minimal: Write as few serial tests as possible - they reduce parallelism</li> <li>Isolate state when possible: Consider using test fixtures or containers to avoid needing serial execution</li> <li>Document why: Add comments explaining why a test needs serial execution</li> </ul> <pre><code>// Named groups allow different concerns to run in parallel\n#[tanu::test(serial = \"database\")]\nasync fn db_test_1() -&gt; eyre::Result&lt;()&gt; {\n    // Database tests run sequentially within this group\n    Ok(())\n}\n\n#[tanu::test(serial = \"filesystem\")]\nasync fn file_test_1() -&gt; eyre::Result&lt;()&gt; {\n    // Filesystem tests run in parallel with database group\n    Ok(())\n}\n\n#[tanu::test]\nasync fn api_test_1() -&gt; eyre::Result&lt;()&gt; {\n    // Regular tests run in parallel with everything\n    Ok(())\n}\n</code></pre> <p>Avoid unnecessary serial execution:</p> <pre><code>// Bad - Unnecessarily serial\n#[tanu::test(serial)]\nasync fn test_pure_computation() -&gt; eyre::Result&lt;()&gt; {\n    let result = 2 + 2;\n    check_eq!(result, 4);\n    Ok(())\n}\n\n// Good - Parallel by default\n#[tanu::test]\nasync fn test_pure_computation() -&gt; eyre::Result&lt;()&gt; {\n    let result = 2 + 2;\n    check_eq!(result, 4);\n    Ok(())\n}\n</code></pre> <p>Serial with parameterized tests:</p> <pre><code>// Serial tests can be parameterized too\n#[tanu::test(serial = \"api\", 200)]\n#[tanu::test(serial = \"api\", 201)]\n#[tanu::test(serial = \"api\", 204)]\nasync fn test_api_status_codes(status: u16) -&gt; eyre::Result&lt;()&gt; {\n    // All parameterized tests run serially within the \"api\" group\n    Ok(())\n}\n</code></pre>"},{"location":"best-practices/#spawning-tokio-tasks-scope_current","title":"Spawning Tokio Tasks (<code>scope_current</code>)","text":"<p>Tanu stores per-test context (project/test metadata used by <code>check!</code>/<code>check_eq!</code> and <code>get_config()</code>) in Tokio task-local storage. Tokio task-locals are not automatically propagated into tasks created with <code>tokio::spawn</code> or <code>JoinSet::spawn</code>.</p> <p>If a spawned task calls <code>tanu::get_config()</code> or uses tanu assertion macros, it can panic with:</p> <pre><code>cannot access a task-local storage value without setting it first\n</code></pre> <p>Wrap spawned futures with <code>tanu::scope_current(...)</code> to propagate the current tanu context:</p> <pre><code>use tanu::{check, eyre};\n\n#[tanu::test]\nasync fn concurrent_work_with_spawn() -&gt; eyre::Result&lt;()&gt; {\n    let handle = tokio::spawn(tanu::scope_current(async move {\n        check!(true);\n        let _cfg = tanu::get_config();\n        eyre::Ok(())\n    }));\n\n    handle.await??;\n    Ok(())\n}\n</code></pre>"},{"location":"best-practices/#use-appropriate-timeouts","title":"Use Appropriate Timeouts","text":"<p>Configure timeouts based on expected response times:</p> <pre><code>let response = client\n    .get(\"https://api.example.com/slow-endpoint\")\n    .timeout(Duration::from_secs(30))  // Adjust based on endpoint\n    .send()\n    .await?;\n</code></pre>"},{"location":"best-practices/#batch-related-assertions","title":"Batch Related Assertions","text":"<p>Group related assertions together to minimize API calls:</p> <pre><code>#[tanu::test]\nasync fn validate_user_profile_completely() -&gt; eyre::Result&lt;()&gt; {\n    let response = client.get(\"/users/123\").send().await?;\n    let user: serde_json::Value = response.json().await?;\n\n    // Multiple assertions on the same response\n    check_eq!(123, user[\"id\"].as_i64().unwrap());\n    check_eq!(\"John Doe\", user[\"name\"].as_str().unwrap());\n    check_eq!(\"john@example.com\", user[\"email\"].as_str().unwrap());\n    check!(user[\"verified\"].as_bool().unwrap());\n\n    Ok(())\n}\n</code></pre>"},{"location":"best-practices/#security-best-practices","title":"Security Best Practices","text":""},{"location":"best-practices/#dont-hardcode-sensitive-data","title":"Don't Hardcode Sensitive Data","text":"<p>Use environment variables or configuration for sensitive information:</p> <pre><code>// Good\nlet api_key = std::env::var(\"API_KEY\")\n    .map_err(|_| eyre::eyre!(\"API_KEY environment variable not set\"))?;\n\nlet response = client\n    .get(\"https://api.example.com/protected\")\n    .header(\"authorization\", format!(\"Bearer {}\", api_key))\n    .send()\n    .await?;\n\n// Avoid\nlet response = client\n    .get(\"https://api.example.com/protected\")\n    .header(\"authorization\", \"Bearer sk-1234567890abcdef\")  // Hardcoded!\n    .send()\n    .await?;\n</code></pre> <p>Automatic HTTP Log Masking</p> <p>Tanu automatically masks sensitive data (API keys, tokens, passwords) in HTTP logs when using <code>--capture-http</code>. See the Automatic Sensitive Data Masking section for details.</p>"},{"location":"best-practices/#validate-ssl-certificates","title":"Validate SSL Certificates","text":"<p>Ensure your tests validate SSL certificates in production environments (this is the default behavior).</p>"},{"location":"best-practices/#use-https-in-production-tests","title":"Use HTTPS in Production Tests","text":"<p>Always use HTTPS endpoints when testing production or staging environments.</p>"},{"location":"best-practices/#automatic-sensitive-data-masking","title":"Automatic Sensitive Data Masking","text":"<p>Tanu automatically masks sensitive data in HTTP logs when using the <code>--capture-http</code> flag to prevent accidental credential leakage. This feature helps you debug HTTP requests safely without exposing API keys, tokens, or passwords in your terminal output or CI/CD logs.</p> <p>What Gets Masked:</p> <p>Sensitive query parameters (case-insensitive): - <code>api_key</code> - <code>apikey</code> - <code>access_token</code> - <code>token</code> - <code>secret</code> - <code>password</code> - <code>key</code> - <code>auth</code></p> <p>Sensitive headers (case-insensitive): - <code>authorization</code> - <code>x-api-key</code> - <code>x-auth-token</code> - <code>cookie</code></p> <p>How It Works:</p> <pre><code># Run tests with HTTP logging - sensitive data will be masked\ncargo run -- test --capture-http\n\n# Example output (masked):\n# =&gt; GET https://api.example.com/users?api_key=*****&amp;user=alice\n#   &gt; request:\n#     &gt; headers:\n#        &gt; authorization: *****\n#        &gt; content-type: application/json\n</code></pre> <p>The actual HTTP requests sent to the server contain the real values - only the logs are masked. This means your tests work correctly while keeping your logs secure.</p> <p>Show Sensitive Data for Debugging:</p> <p>During local development or debugging, you may want to see the actual values:</p> <pre><code># Show sensitive data in logs (use with caution)\ncargo run -- test --capture-http --show-sensitive\n\n# Example output (unmasked):\n# =&gt; GET https://api.example.com/users?api_key=sk-1234567890&amp;user=alice\n#   &gt; request:\n#     &gt; headers:\n#        &gt; authorization: Bearer my-secret-token\n#        &gt; content-type: application/json\n</code></pre> <p>Best Practices:</p> <ol> <li> <p>Never use <code>--show-sensitive</code> in CI/CD: Always use the default masked mode in continuous integration environments to prevent credential leaks in build logs.</p> </li> <li> <p>Review logs before sharing: Even with masking enabled, review captured HTTP logs before sharing them publicly to ensure no sensitive data is exposed.</p> </li> <li> <p>Use environment variables: Store credentials in environment variables rather than hardcoding them:</p> </li> </ol> <pre><code>#[tanu::test]\nasync fn api_call_with_credentials() -&gt; eyre::Result&lt;()&gt; {\n    let api_key = std::env::var(\"API_KEY\")\n        .map_err(|_| eyre::eyre!(\"API_KEY not set\"))?;\n\n    let response = client\n        .get(\"https://api.example.com/protected\")\n        .query(&amp;[(\"api_key\", api_key)])\n        .send()\n        .await?;\n\n    check!(response.status().is_success());\n    Ok(())\n}\n</code></pre> <ol> <li> <p>URL encoding is preserved: The masking feature preserves URL encoding in query parameters, so <code>name=john%20doe</code> remains properly encoded even after masking nearby sensitive params.</p> </li> <li> <p>Test your integrations safely: With automatic masking, you can capture HTTP logs even when testing against real APIs with actual credentials, making debugging production issues much safer.</p> </li> </ol> <p>Example Test:</p> <pre><code>use tanu::{check, check_eq, eyre, http::Client};\n\n#[tanu::test]\nasync fn test_authenticated_api_call() -&gt; eyre::Result&lt;()&gt; {\n    let api_key = std::env::var(\"API_KEY\")?;\n\n    let client = Client::new();\n    let response = client\n        .get(\"https://api.example.com/data\")\n        .header(\"x-api-key\", api_key)\n        .query(&amp;[\n            (\"access_token\", \"secret_token_123\"),\n            (\"user_id\", \"alice\"),\n        ])\n        .send()\n        .await?;\n\n    check!(response.status().is_success());\n\n    // When run with --capture-http, the logs will show:\n    // =&gt; GET https://api.example.com/data?access_token=*****&amp;user_id=alice\n    //   &gt; request:\n    //     &gt; headers:\n    //        &gt; x-api-key: *****\n    //        &gt; content-type: application/json\n\n    Ok(())\n}\n</code></pre> <p>This automatic masking feature ensures you can debug HTTP requests safely without compromising security, making it ideal for both local development and CI/CD environments.</p>"},{"location":"best-practices/#error-handling","title":"Error Handling","text":""},{"location":"best-practices/#use-meaningful-error-messages","title":"Use Meaningful Error Messages","text":"<p>Provide context when tests fail:</p> <pre><code>#[tanu::test]\nasync fn comprehensive_error_handling() -&gt; eyre::Result&lt;()&gt; {\n    let response = client\n        .post(\"https://api.example.com/users\")\n        .json(&amp;user_data)\n        .send()\n        .await\n        .map_err(|e| eyre::eyre!(\"Failed to send request to create user: {}\", e))?;\n\n    if !response.status().is_success() {\n        let error_body = response.text().await?;\n        return Err(eyre::eyre!(\n            \"User creation failed with status {}: {}\", \n            response.status(), \n            error_body\n        ));\n    }\n\n    Ok(())\n}\n</code></pre>"},{"location":"best-practices/#handle-rate-limiting","title":"Handle Rate Limiting","text":"<p>Be respectful of API rate limits:</p> <pre><code>use tokio::time::{sleep, Duration};\n\n#[tanu::test]\nasync fn rate_limited_test() -&gt; eyre::Result&lt;()&gt; {\n    for i in 0..10 {\n        let response = client.get(\"/api/endpoint\").send().await?;\n\n        if response.status().as_u16() == 429 {\n            // Rate limited, wait before retrying\n            sleep(Duration::from_secs(1)).await;\n            continue;\n        }\n\n        check!(response.status().is_success());\n\n        // Small delay between requests\n        if i &lt; 9 {\n            sleep(Duration::from_millis(100)).await;\n        }\n    }\n\n    Ok(())\n}\n</code></pre>"},{"location":"best-practices/#maintenance","title":"Maintenance","text":""},{"location":"best-practices/#keep-tests-up-to-date","title":"Keep Tests Up to Date","text":"<p>Regularly review and update tests as APIs evolve:</p> <ul> <li>Update endpoint URLs when they change</li> <li>Modify assertions when response formats change  </li> <li>Add tests for new API features</li> <li>Remove tests for deprecated functionality</li> </ul>"},{"location":"best-practices/#document-complex-test-logic","title":"Document Complex Test Logic","text":"<p>Add comments for complex test scenarios:</p> <pre><code>#[tanu::test]\nasync fn complex_workflow_test() -&gt; eyre::Result&lt;()&gt; {\n    // Step 1: Create user account\n    let user_response = client.post(\"/users\").json(&amp;user_data).send().await?;\n    let user_id = user_response.json::&lt;serde_json::Value&gt;().await?[\"id\"].as_i64().unwrap();\n\n    // Step 2: Verify email (simulated)\n    client.post(&amp;format!(\"/users/{}/verify\", user_id)).send().await?;\n\n    // Step 3: Login with verified account\n    let login_response = client\n        .post(\"/auth/login\")\n        .json(&amp;login_data)\n        .send()\n        .await?;\n\n    check!(login_response.status().is_success(), \"Login should succeed after verification\");\n\n    Ok(())\n}\n</code></pre>"},{"location":"best-practices/#regular-cleanup","title":"Regular Cleanup","text":"<ul> <li>Remove obsolete tests</li> <li>Consolidate duplicate test logic</li> <li>Update dependencies regularly</li> <li>Review and update configuration files</li> </ul>"},{"location":"best-practices/#result-type-flexibility","title":"Result Type Flexibility","text":"<p>Tanu supports various Result types, allowing you to choose the error handling approach that best fits your needs:</p> <pre><code>// eyre::Result (recommended)\n#[tanu::test]\nasync fn test_with_eyre() -&gt; eyre::Result&lt;()&gt; {\n    let response = client.get(\"/api/endpoint\").send().await?;\n    check!(response.status().is_success());\n    Ok(())\n}\n\n// anyhow::Result  \n#[tanu::test]\nasync fn test_with_anyhow() -&gt; anyhow::Result&lt;()&gt; {\n    let response = client.get(\"/api/endpoint\").send().await\n        .map_err(|e| anyhow::anyhow!(\"Request failed: {}\", e))?;\n\n    if !response.status().is_success() {\n        return Err(anyhow::anyhow!(\"Expected success, got: {}\", response.status()));\n    }\n    Ok(())\n}\n\n// Custom error types\n#[derive(Debug)]\nenum ApiError {\n    Network(String),\n    InvalidResponse(String),\n}\n\nimpl std::fmt::Display for ApiError {\n    fn fmt(&amp;self, f: &amp;mut std::fmt::Formatter&lt;'_&gt;) -&gt; std::fmt::Result {\n        match self {\n            ApiError::Network(msg) =&gt; write!(f, \"Network error: {}\", msg),\n            ApiError::InvalidResponse(msg) =&gt; write!(f, \"Invalid response: {}\", msg),\n        }\n    }\n}\n\nimpl std::error::Error for ApiError {}\n\n#[tanu::test]\nasync fn test_with_custom_error() -&gt; Result&lt;(), ApiError&gt; {\n    let response = client.get(\"/api/endpoint\").send().await\n        .map_err(|e| ApiError::Network(e.to_string()))?;\n\n    if !response.status().is_success() {\n        return Err(ApiError::InvalidResponse(\n            format!(\"Status: {}\", response.status())\n        ));\n    }\n    Ok(())\n}\n\n// Simple string errors\n#[tanu::test]\nasync fn test_with_string_error() -&gt; Result&lt;(), String&gt; {\n    let response = client.get(\"/api/endpoint\").send().await\n        .map_err(|e| format!(\"Request failed: {}\", e))?;\n\n    if !response.status().is_success() {\n        return Err(format!(\"Expected success, got: {}\", response.status()));\n    }\n    Ok(())\n}\n</code></pre> <p>Recommendation: Use <code>eyre::Result</code> for best experience</p> <p>While tanu supports <code>anyhow::Result</code>, <code>std::result::Result</code>, and custom error types, we strongly recommend using <code>eyre::Result</code> for the following reasons:</p> <ul> <li>Seamless integration: Tanu's <code>check!</code>, <code>check_eq!</code>, and other assertion macros return <code>eyre::Result</code>, providing perfect compatibility</li> <li>Colored backtraces: eyre provides beautiful, colored error backtraces that make debugging much easier</li> <li>Rich error context: eyre excels at capturing and displaying error context chains</li> <li>Zero friction: No need for manual error conversions or custom assertion logic</li> <li>Consistent experience: Best integration with tanu's error reporting and TUI</li> </ul> <p>Alternative Result types: - Use <code>anyhow::Result</code> when you need compatibility with existing anyhow-based code (requires manual assertions) - Use custom error types when you want specific error categorization or need to implement particular error handling logic - Use <code>Result&lt;(), String&gt;</code> for simple tests where detailed error handling isn't critical</p> <p>Important: When using non-eyre Result types, you cannot use tanu's <code>check!</code> macros directly since they return <code>eyre::Result</code>. You'll need to write manual assertions as shown in the examples above.</p> <p>By following these best practices, you'll create maintainable, reliable, and effective API tests with tanu.</p>"},{"location":"command-line-option/","title":"Command Line Options","text":"<p>Tip</p> <p>Many command-line options can be configured as defaults in <code>tanu.toml</code> under the <code>[runner]</code> section. See the Configuration page for details. Command-line flags always override configuration file settings.</p>"},{"location":"command-line-option/#test","title":"<code>test</code>","text":"<p>Run tests with tanu.</p>"},{"location":"command-line-option/#options","title":"Options","text":"<ul> <li><code>--capture-http</code>         Capture http debug logs. Can also be set in <code>tanu.toml</code> as <code>runner.capture_http = true</code>.</li> <li><code>--show-sensitive</code>       Show sensitive data (API keys, tokens) in HTTP logs instead of masking them. By default, sensitive query parameters (api_key, access_token, token, secret, password) and headers (authorization, x-api-key, cookie) are masked with <code>*****</code> for security. Use this flag to display actual values during debugging. Can also be set in <code>tanu.toml</code> as <code>runner.show_sensitive = true</code>.</li> <li><code>--capture-rust</code>         Capture Rust \"log\" crate based logs. This is usefull in the following two cases 1) tanu failed unexpectedly and you would want to see the tanu's internal logs. 2) you would want to see logs produced from your tests that uses \"log\" crate. Can also be set in <code>tanu.toml</code> as <code>runner.capture_rust = true</code>.</li> <li><code>-p, --projects &lt;PROJECTS&gt;</code>  Run only the specified projects. This option can be specified multiple times e.g. --projects dev --projects staging</li> <li><code>-m, --modules &lt;MODULES&gt;</code>    Run only the specified modules. This option can be specified multiple times e.g. --modules foo --modules bar</li> <li><code>-t, --tests &lt;TESTS&gt;</code>        Run only the specified test cases. This option can be specified multiple times e.g. --tests a ---tests b</li> <li><code>--reporter &lt;REPORTER&gt;</code>  Specify the reporter to use. Default is \"table\". Possible values are \"table\", \"list\" and \"null\"</li> <li><code>-c, --concurrency &lt;NUMBER&gt;</code> Specify the maximum number of tests to run in parallel. When unspecified, all tests run in parallel. Can also be set in <code>tanu.toml</code> as <code>runner.concurrency = 4</code>.</li> <li><code>--color &lt;WHEN&gt;</code>         Control when colored output is used. Possible values are \"auto\" (default), \"always\", or \"never\". Environment variable <code>CARGO_TERM_COLOR</code> is also respected.</li> </ul>"},{"location":"command-line-option/#tui","title":"<code>tui</code>","text":"<p>Launch the TUI (Text User Interface) for tanu.</p>"},{"location":"command-line-option/#options_1","title":"Options","text":"<ul> <li><code>--log-level &lt;LOG_LEVEL&gt;</code>            [default: Info]</li> <li><code>--tanu-log-level &lt;TANU_LOG_LEVEL&gt;</code>  [default: Info]</li> <li><code>-c, --concurrency &lt;NUMBER&gt;</code> Specify the maximum number of tests to run in parallel. Default is the number of logical CPU cores. Can also be set in <code>tanu.toml</code> as <code>runner.concurrency = 4</code>.</li> </ul>"},{"location":"command-line-option/#ls","title":"<code>ls</code>","text":"<p>List test cases.</p>"},{"location":"command-line-option/#help","title":"<code>help</code>","text":"<p>Print this message or the help of the given subcommand(s).</p>"},{"location":"command-line-option/#options_2","title":"Options","text":"<ul> <li><code>-h, --help</code> Print help.</li> <li><code>-V, --version</code> Print version.</li> </ul>"},{"location":"configuration/","title":"tanu.toml Configuration","text":"<p>The <code>tanu.toml</code> file is used to configure different project environments for the tanu application.</p>"},{"location":"configuration/#structure","title":"Structure","text":"<p>The [[projects]] tables in the tanu.toml file allow you to define different configurations for various environments. This is inspired by Playwright and enables you to iterate the same set of tests with different configurations or environments. You can make as many projects as you want.</p> <p>The <code>tanu.toml</code> file consists of multiple <code>[[projects]]</code> tables, each representing a different environment. Each table contains the following fields:</p> <ul> <li><code>name</code>: The name of the project (e.g., \"dev\", \"staging\", \"production\").</li> <li><code>test_ignore</code>: A list of test cases to ignore for the environment.</li> </ul>"},{"location":"configuration/#example","title":"Example","text":"<p>Below is an example of a <code>tanu.toml</code> file:</p> <pre><code>[tui]\npayload.color_theme = \"tomorrow-night\"  # Replace with your preferred theme name\n\n[runner]\ncapture_http = true     # Capture HTTP debug logs\nconcurrency = 4         # Run up to 4 tests in parallel\n\n[[projects]]\nname = \"staging\"\ntest_ignore = [\n  \"feature_flag::feature_flag_enabled\",\n  \"feature_flag::feature_flag_disabled\",\n]\nretry.count = 3\nretry.factor = 2.0\nretry.jitter = true\nretry.min_delay = \"1s\"\nretry.max_delay = \"60s\"\n\n[[projects]]\nname = \"production\"\ntest_ignore = []\nretry.count = 3\nretry.factor = 2.0\nretry.jitter = true\nretry.min_delay = \"1s\"\nretry.max_delay = \"60s\"\n</code></pre>"},{"location":"configuration/#runner","title":"Runner","text":"<p>The <code>[runner]</code> section configures global test execution behavior. All values are optional and serve as defaults that can be overridden by command-line flags.</p> <pre><code>[runner]\ncapture_http = true      # Capture HTTP debug logs (default: false)\ncapture_rust = false     # Capture Rust \"log\" crate logs (default: false)\nshow_sensitive = false   # Show sensitive data in HTTP logs (default: false)\nconcurrency = 4          # Max parallel tests (default: unlimited for CLI, CPU cores for TUI)\n</code></pre>"},{"location":"configuration/#options","title":"Options","text":"<ul> <li><code>capture_http</code>: When enabled, captures and displays HTTP request/response logs for debugging. Default is <code>false</code>. Can be overridden with <code>--capture-http</code>.</li> <li><code>capture_rust</code>: When enabled, captures logs from Rust's <code>log</code> crate. Useful for debugging tanu internals or test code that uses the log crate. Default is <code>false</code>. Can be overridden with <code>--capture-rust</code>.</li> <li><code>show_sensitive</code>: When enabled, displays sensitive data (API keys, tokens, passwords) in HTTP logs instead of masking them with <code>*****</code>. Use with caution as this may expose secrets. Default is <code>false</code>. Can be overridden with <code>--show-sensitive</code>.</li> <li><code>concurrency</code>: Maximum number of tests to run in parallel. If not specified, CLI mode runs all tests in parallel (unlimited), while TUI mode defaults to the number of CPU cores. Can be overridden with <code>-c</code> or <code>--concurrency</code>.</li> </ul> <p>Note</p> <p>Command-line flags always take precedence over configuration file settings. Use configuration file settings to establish project defaults and command-line flags for one-off overrides.</p>"},{"location":"configuration/#retry","title":"Retry","text":"<p>This section describes the HTTP retry configuration for the project. All values are optional. If the retry configuration is entirely omitted, retries are disabled by default. If configured, the Tanu runner will perform retry attempts if a request fails. - <code>retry.count</code>: The number of retry attempts. Default is 0. - <code>retry.factor</code>: The factor for exponential backoff. Default is 2.0. - <code>retry.jitter</code>: A boolean to enable or disable backoff jitter. Default is false. - <code>retry.min_delay</code>: The minimum delay for backoff. Default is \"1s\". - <code>retry.max_delay</code>: The maximum delay for backoff. Default is \"60s\".</p>"},{"location":"configuration/#user-defined-settings","title":"User defined settings","text":"<p>tanu allows you to set user-defined settings in <code>tanu.toml</code>. You can set arbitrary key-value pairs under each project setting.</p> <p>Here is an example specifying different <code>base_url</code> values for staging and production environments:</p> <pre><code>[[projects]]\nname = \"staging\"\nbase_url = \"https://api.production.foobar.com\"\n\n[[projects]]\nname = \"production\"\nbase_url = \"https://api.staging.foobar.com\"\n</code></pre> <p>In your test code, you can retrieve the value for the current project using the following method: <pre><code>tanu::get_config().get_str(\"base_url\")?;\n</code></pre></p> <p>If the value is not string, you can use other methods to retrieve it:</p> <ul> <li>get_int</li> <li>get_float</li> <li>get_bool</li> <li>get_datetime</li> <li>get_array</li> <li>get_object</li> </ul>"},{"location":"configuration/#environment-variables","title":"Environment variables","text":""},{"location":"configuration/#config-file-location","title":"Config file location","text":"<p>By default, tanu looks for <code>tanu.toml</code> in the current directory. You can specify a custom config file path using the <code>TANU_CONFIG</code> environment variable:</p> <pre><code># Use a custom config file\nTANU_CONFIG=/path/to/my-config.toml tanu test\n\n# Or export it\nexport TANU_CONFIG=/path/to/my-config.toml\ntanu test\n</code></pre> <p>Warning</p> <p><code>TANU_CONFIG</code> is reserved for specifying the config file path. Do not use it as a config value key (e.g., <code>TANU_CONFIG=true</code>). Tanu will error if it detects misuse.</p>"},{"location":"configuration/#user-defined-config-values","title":"User-defined config values","text":"<p>Tanu also allows you to set user-defined settings in a <code>.env</code> file. Secret settings like API keys should not be stored in plain text; instead, environment variables should be used.</p> <p>Global config values: Any environment variable prefixed with <code>TANU_</code> will be exposed as a configuration value accessible from all projects.</p> <pre><code># Accessible as get_config().get_str(\"api_key\") in all projects\nexport TANU_API_KEY=secret123\n</code></pre> <p>Project-specific config values: Any environment variable prefixed with <code>TANU_{PROJECT}_</code> will be exposed as a configuration for that specific project. For example, an API key set in the <code>TANU_STAGING_API_KEY</code> environment variable can be accessed using <code>tanu::get_config().get_str(\"api_key\")</code> when running the \"staging\" project.</p>"},{"location":"configuration/#theme","title":"Theme","text":"<p>You can customize the appearance of Tanu's interface by selecting a color theme.</p> <p>To change the theme, add the following to your <code>tanu.toml</code> configuration file:</p> <pre><code>[tui]\npayload.color_theme = \"tomorrow-night\"  # Replace with your preferred theme name\n</code></pre> <p>Note</p> <p>The color theme setting primarily affects the Payload tab in the TUI, where it's used to colorize and syntax-highlight response payloads (particularly JSON responses). This makes the API responses more readable and helps you quickly identify different elements in the response data.</p>"},{"location":"configuration/#available-themes","title":"Available Themes","text":"<p>Tanu ships with all Base16 themes, providing a consistent color palette across different interfaces. Available themes include:</p> <ul> <li><code>3024</code></li> <li><code>apathy</code></li> <li><code>ashes</code></li> <li><code>atelier-cave</code></li> <li><code>atelier-dune</code></li> <li><code>atelier-estuary</code></li> <li><code>atelier-forest</code></li> <li><code>atelier-heath</code></li> <li><code>atelier-lakeside</code></li> <li><code>atelier-plateau</code></li> <li><code>atelier-savanna</code></li> <li><code>atelier-seaside</code></li> <li><code>atelier-sulphurpool</code></li> <li><code>atlas</code></li> <li><code>bespin</code></li> <li><code>black-metal</code></li> <li><code>brewer</code></li> <li><code>bright</code></li> <li><code>brushtrees</code></li> <li><code>chalk</code></li> <li><code>circus</code></li> <li><code>classic</code></li> <li><code>codeschool</code></li> <li><code>cupcake</code></li> <li><code>cupertino</code></li> <li><code>darktooth</code></li> <li><code>default</code></li> <li><code>eighties</code></li> <li><code>embers</code></li> <li><code>flat</code></li> <li><code>fruit-soda</code></li> <li><code>github</code></li> <li><code>google</code></li> <li><code>grayscale</code></li> <li><code>greenscreen</code></li> <li><code>gruvbox</code></li> <li><code>harmonic</code></li> <li><code>hopscotch</code></li> <li><code>irblack</code></li> <li><code>isotope</code></li> <li><code>macintosh</code></li> <li><code>marrakesh</code></li> <li><code>materia</code></li> <li><code>material</code></li> <li><code>mellow</code></li> <li><code>mexico</code></li> <li><code>mocha</code></li> <li><code>monokai</code></li> <li><code>nord</code></li> <li><code>ocean</code></li> <li><code>oceanicnext</code></li> <li><code>one</code></li> <li><code>onedark</code></li> <li><code>papercolor</code></li> <li><code>paraiso</code></li> <li><code>phd</code></li> <li><code>pico</code></li> <li><code>pop</code></li> <li><code>porple</code></li> <li><code>railscasts</code></li> <li><code>rebecca</code></li> <li><code>seti</code></li> <li><code>shapeshifter</code></li> <li><code>solarflare</code></li> <li><code>solarized</code></li> <li><code>spacemacs</code></li> <li><code>summerfruit</code></li> <li><code>tomorrow</code></li> <li><code>tomorrow-night</code></li> <li><code>tube</code></li> <li><code>twilight</code></li> <li><code>unikitty</code></li> <li><code>woodland</code></li> <li><code>xcode</code></li> <li><code>zenburn</code></li> </ul>"},{"location":"faq/","title":"Frequently Asked Questions (FAQ)","text":"<p>tags:   - FAQ   - Getting Started   - Configuration   - HTTP</p>"},{"location":"faq/#general-questions","title":"General Questions","text":""},{"location":"faq/#what-is-tanu","title":"What is tanu?","text":"<p>Tanu is a high-performance, async-friendly WebAPI testing framework for Rust. It's designed to be fast, type-safe, ergonomic, and easily extensible with full support for concurrency and async operations.</p>"},{"location":"faq/#how-is-tanu-different-from-using-standard-rust-test-framework-with-reqwest","title":"How is tanu different from using standard Rust test framework with reqwest?","text":"<p>While you can write API tests using <code>#[test]</code> with tokio and reqwest, tanu provides: - Dedicated test discovery and execution system - Built-in HTTP client with logging - Ergonomic assertion macros designed for API testing - Terminal UI for interactive test execution - Configuration system for multiple environments - Parameterized test support</p>"},{"location":"faq/#is-tanu-production-ready","title":"Is tanu production-ready?","text":"<p>Yes, tanu is actively developed and used for testing production APIs. The framework follows semantic versioning and maintains backward compatibility.</p>"},{"location":"faq/#installation-setup","title":"Installation &amp; Setup","text":""},{"location":"faq/#what-are-the-minimum-requirements","title":"What are the minimum requirements?","text":"<ul> <li>Rust 1.70 or later</li> <li>Cargo package manager</li> <li>tokio runtime for async support</li> </ul>"},{"location":"faq/#how-do-i-install-tanu","title":"How do I install tanu?","text":"<p>Add tanu to your Cargo.toml: <pre><code>cargo add tanu\ncargo add tokio --features full\n</code></pre></p>"},{"location":"faq/#can-i-use-tanu-in-an-existing-rust-project","title":"Can I use tanu in an existing Rust project?","text":"<p>Yes! Tanu can be added to any Rust project. You can create a separate binary for your tests or integrate them into your existing test suite.</p>"},{"location":"faq/#writing-tests","title":"Writing Tests","text":""},{"location":"faq/#how-do-i-write-a-basic-test","title":"How do I write a basic test?","text":"<pre><code>use tanu::{check, eyre, http::Client};\n\n#[tanu::test]\nasync fn my_test() -&gt; eyre::Result&lt;()&gt; {\n    let client = Client::new();\n    let response = client.get(\"https://api.example.com\").send().await?;\n    check!(response.status().is_success());\n    Ok(())\n}\n</code></pre>"},{"location":"faq/#can-i-use-parameterized-tests","title":"Can I use parameterized tests?","text":"<p>Yes! Use multiple <code>#[tanu::test(param)]</code> attributes: <pre><code>#[tanu::test(200)]\n#[tanu::test(404)]\n#[tanu::test(500)]\nasync fn test_status_codes(status: u16) -&gt; eyre::Result&lt;()&gt; {\n    // Test implementation\n    Ok(())\n}\n</code></pre></p>"},{"location":"faq/#how-do-i-handle-authentication","title":"How do I handle authentication?","text":"<p>Add headers to your requests: <pre><code>let response = client\n    .get(\"https://api.example.com/protected\")\n    .header(\"authorization\", \"Bearer your-token\")\n    .send()\n    .await?;\n</code></pre></p>"},{"location":"faq/#what-assertion-macros-are-available","title":"What assertion macros are available?","text":"<ul> <li><code>check!(condition)</code> - Basic boolean assertion</li> <li><code>check_eq!(expected, actual)</code> - Equality assertion</li> <li><code>check_ne!(expected, actual)</code> - Non-equality assertion</li> <li><code>check_str_eq!(expected, actual)</code> - String equality with better diff output</li> </ul>"},{"location":"faq/#http-features","title":"HTTP Features","text":""},{"location":"faq/#does-tanu-support-cookies","title":"Does tanu support cookies?","text":"<p>Yes! Enable the cookies feature: <pre><code>tanu = { version = \"*\", features = [\"cookies\"] }\n</code></pre></p> <p>Then use the cookies API: <pre><code>let cookies = response.cookies();\nfor cookie in cookies {\n    println!(\"{}={}\", cookie.name(), cookie.value());\n}\n</code></pre></p>"},{"location":"faq/#what-http-methods-are-supported","title":"What HTTP methods are supported?","text":"<p>All standard HTTP methods: GET, POST, PUT, PATCH, DELETE, HEAD, OPTIONS.</p>"},{"location":"faq/#can-i-send-json-data","title":"Can I send JSON data?","text":"<p>Yes, with the json feature enabled: <pre><code>let response = client\n    .post(\"https://api.example.com/users\")\n    .json(&amp;user_data)\n    .send()\n    .await?;\n</code></pre></p>"},{"location":"faq/#how-do-i-handle-different-content-types","title":"How do I handle different content types?","text":"<p>Use appropriate headers: <pre><code>let response = client\n    .post(\"https://api.example.com/data\")\n    .header(\"content-type\", \"application/xml\")\n    .body(xml_data)\n    .send()\n    .await?;\n</code></pre></p>"},{"location":"faq/#configuration","title":"Configuration","text":""},{"location":"faq/#how-do-i-configure-different-environments","title":"How do I configure different environments?","text":"<p>Create a <code>tanu.toml</code> file: <pre><code>[[projects]]\nname = \"staging\"\nbase_url = \"https://staging.api.example.com\"\n\n[[projects]]\nname = \"production\"\nbase_url = \"https://api.example.com\"\n</code></pre></p>"},{"location":"faq/#can-i-ignore-specific-tests","title":"Can I ignore specific tests?","text":"<p>Yes, use the <code>test_ignore</code> configuration: <pre><code>[[projects]]\nname = \"default\"\ntest_ignore = [\"slow_test\", \"flaky_test\"]\n</code></pre></p>"},{"location":"faq/#how-do-i-configure-retry-behavior","title":"How do I configure retry behavior?","text":"<p>Add retry configuration to your project: <pre><code>[[projects]]\nname = \"default\"\nretry.count = 3\nretry.factor = 2.0\nretry.jitter = true\n</code></pre></p>"},{"location":"faq/#running-tests","title":"Running Tests","text":""},{"location":"faq/#how-do-i-run-tests","title":"How do I run tests?","text":"<pre><code>cargo run                    # Run all tests\ncargo run test             # Run all tests (explicit)\ncargo run test -t pattern  # Run tests matching pattern\n</code></pre>"},{"location":"faq/#can-i-run-tests-in-parallel","title":"Can I run tests in parallel?","text":"<p>Yes, tanu runs tests concurrently by default. You can control concurrency using:</p> <ul> <li>Command-line flag: <code>--concurrency 4</code> or <code>-c 4</code></li> <li>Configuration file: <code>runner.concurrency = 4</code> in <code>tanu.toml</code></li> </ul> <p>See the Runner Configuration section for more details.</p>"},{"location":"faq/#how-do-i-use-the-tui-mode","title":"How do I use the TUI mode?","text":"<pre><code>cargo run tui\n</code></pre> <p>This opens an interactive terminal interface for running and monitoring tests.</p>"},{"location":"faq/#troubleshooting","title":"Troubleshooting","text":""},{"location":"faq/#my-tests-are-failing-with-connection-errors","title":"My tests are failing with connection errors","text":"<ul> <li>Check if the API endpoint is accessible</li> <li>Verify network connectivity</li> <li>Consider timeouts and retry configuration</li> <li>Check if authentication is required</li> </ul>"},{"location":"faq/#i-see-a-panic-cannot-access-a-task-local-storage-value-without-setting-it-first","title":"I see a panic: \"cannot access a task-local storage value without setting it first\"","text":"<p>This usually happens when you spawn background tasks (e.g. <code>tokio::spawn</code>, <code>JoinSet::spawn</code>) from inside a <code>#[tanu::test]</code> and the spawned task calls <code>tanu::get_config()</code> or uses tanu assertion macros (<code>check!</code>, <code>check_eq!</code>, etc.).</p> <p>Tokio task-local context is not propagated automatically into spawned tasks. Wrap the spawned future with <code>tanu::scope_current(...)</code>:</p> <pre><code>#[tanu::test]\nasync fn spawned_task_uses_tanu_apis() -&gt; eyre::Result&lt;()&gt; {\n    let handle = tokio::spawn(tanu::scope_current(async move {\n        tanu::check!(true);\n        let _cfg = tanu::get_config();\n        eyre::Ok(())\n    }));\n    handle.await??;\n    Ok(())\n}\n</code></pre>"},{"location":"faq/#im-getting-function-not-found-errors","title":"I'm getting \"function not found\" errors","text":"<p>Make sure you've added the required features to your Cargo.toml: <pre><code>tanu = { version = \"*\", features = [\"json\", \"cookies\"] }\n</code></pre></p>"},{"location":"faq/#tests-work-individually-but-fail-when-run-together","title":"Tests work individually but fail when run together","text":"<p>This might be due to: - Shared state between tests - Rate limiting from the API - Authentication token expiration - Resource cleanup issues</p>"},{"location":"faq/#how-do-i-debug-http-requests","title":"How do I debug HTTP requests?","text":"<p>Use the <code>--capture-http</code> flag to capture HTTP request/response logs:</p> <pre><code>cargo run -- test --capture-http\n</code></pre> <p>You can also enable this by default in <code>tanu.toml</code>: <pre><code>[runner]\ncapture_http = true\n</code></pre></p> <p>For interactive debugging, use TUI mode to inspect detailed request information. See Best Practices - HTTP Debugging for more details on automatic sensitive data masking.</p>"},{"location":"faq/#performance","title":"Performance","text":""},{"location":"faq/#how-fast-is-tanu-compared-to-other-tools","title":"How fast is tanu compared to other tools?","text":"<p>Tanu is built in Rust and leverages zero-cost abstractions for minimal overhead. It typically outperforms JavaScript and Python-based testing frameworks.</p>"},{"location":"faq/#can-i-control-test-execution-speed","title":"Can I control test execution speed?","text":"<p>Yes, through configuration: - Adjust concurrency levels with <code>--concurrency</code> flag or <code>runner.concurrency</code> in config - Configure timeouts in your HTTP client - Use retry settings appropriately (see Retry Configuration) - Consider rate limiting for API protection</p>"},{"location":"faq/#integration","title":"Integration","text":""},{"location":"faq/#can-i-use-tanu-in-cicd-pipelines","title":"Can I use tanu in CI/CD pipelines?","text":"<p>Yes! Tanu works well in CI/CD environments. Use the CLI mode for automated testing: <pre><code>cargo run test --reporter json &gt; results.json\n</code></pre></p>"},{"location":"faq/#how-do-i-integrate-with-existing-test-suites","title":"How do I integrate with existing test suites?","text":"<p>Tanu tests can run alongside standard Rust tests. You can organize them in separate modules or binaries as needed.</p>"},{"location":"faq/#can-i-generate-test-reports","title":"Can I generate test reports?","text":"<p>Yes, tanu supports various output formats including JSON for integration with reporting tools.</p>"},{"location":"faq/#contributing","title":"Contributing","text":""},{"location":"faq/#how-can-i-contribute-to-tanu","title":"How can I contribute to tanu?","text":"<ul> <li>Report bugs and feature requests on GitHub</li> <li>Submit pull requests with improvements</li> <li>Write documentation and examples</li> <li>Share your experience with the community</li> </ul>"},{"location":"faq/#where-can-i-get-help","title":"Where can I get help?","text":"<ul> <li>Check this FAQ and documentation</li> <li>Search existing GitHub issues</li> <li>Create a new issue for bugs or feature requests</li> <li>Join community discussions</li> </ul>"},{"location":"getting-started/","title":"Getting Started","text":"<p>To install <code>tanu</code> from crates.io, you need to have Rust and Cargo installed on your system. If you don't have Rust installed, you can install it by following the instructions on the official Rust website.</p> <p>Once you have Rust and Cargo installed, create an example project by running the following commands in your terminal:</p> <pre><code>cargo new example\ncd example\n</code></pre> <p>Next, you can install <code>tanu</code> and <code>tokio</code> by running the following commands in your terminal:</p> <pre><code>cargo add tanu\ncargo add tokio --features full\n</code></pre> <p>Open <code>src/main.rs</code> in your editor, and replace its contents with the following code:</p> <pre><code>use tanu::eyre;\n\n#[tanu::main]\n#[tokio::main]\nasync fn main() -&gt; eyre::Result&lt;()&gt; {\n    let runner = run();\n    let app = tanu::App::new();\n    app.run(runner).await?;\n    Ok(())\n}\n</code></pre> <p>This code sets up a basic <code>tanu</code> application using <code>tokio</code> for asynchronous runtime and <code>eyre</code> for error handling.</p> <p>To run your application, use the following command in your terminal:</p> <pre><code>cargo run\n</code></pre> <p>you will see the output as follows: <pre><code>tanu - High-performance and async-friendly WebAPI testing framework for Rust\n\nUsage: tanu-examples &lt;COMMAND&gt;\n\nCommands:\n  test  Run tests in CLI mode\n  tui   Run tests in TUI mode\n  ls    List test cases\n  help  Print this message or the help of the given subcommand(s)\n\nOptions:\n  -h, --help     Print help\n  -V, --version  Print version\n</code></pre></p> <p>If you want to run tests, you can use:</p> <pre><code>cargo run test\n</code></pre> <p>If there are no tests defined, you should see the following output:</p> <pre><code>No tests have been defined yet.\n</code></pre> <p>Next, define your test case. As you can see below, the function has the <code>#[tanu::test]</code> attribute. This attribute parses the test function and automatically registers it in the tanu's test runner. The test function has to be \"async\" and return a <code>Result&lt;T, E&gt;</code> type.</p> <p>Supported Error Types</p> <p>Tanu supports various Result types for flexible error handling:</p> <ul> <li><code>eyre::Result&lt;()&gt;</code> (recommended) - Provides colored backtraces and seamless integration with tanu's assertion macros</li> <li><code>anyhow::Result&lt;()&gt;</code> - Compatible with existing anyhow-based code</li> <li><code>std::result::Result&lt;(), E&gt;</code> - Standard Rust Result type with custom error types or simple errors like <code>String</code></li> </ul> <p>For the best experience, we recommend using <code>eyre::Result</code> as it integrates perfectly with tanu's <code>check!</code> macros and provides excellent error reporting. For more details on error handling best practices, see our Best Practices guide.</p> <pre><code>#[tanu::test]\nasync fn get() -&gt; eyre::Result&lt;()&gt; {\n    Ok(())\n}\n</code></pre> <p>Now, define the test assertions in the function:</p> <pre><code>use tanu::{check, eyre, http::Client};\n\n#[tanu::test]\nasync fn get() -&gt; eyre::Result&lt;()&gt; {\n    let http = Client::new();\n    let res = http.get(\"https://httpbin.org/get\").send().await?;\n    check!(res.status().is_success());\n    Ok(())\n}\n</code></pre> <p>Run the tanu test runner again:</p> <pre><code>cargo run test\n</code></pre> <p>This time you should see the test execution in your terminal like this:</p> <pre><code>\u2713 [default] crate::get\n</code></pre> <p>tanu offers a TUI-based test runner. To run in TUI mode, use the following command:</p> <pre><code>cargo run tui\n</code></pre> <p>Congratulations! You have successfully set up a basic <code>tanu</code> application. For more advanced usage and features, please refer to the official documentation.</p>"},{"location":"grpc/","title":"gRPC Testing","text":"<p>tags:   - gRPC   - Testing   - API</p> <p>Tanu provides automatic request/response capture for gRPC calls through Tower middleware integration. This allows seamless testing of gRPC services with full observability of method calls, metadata, status codes, and performance metrics.</p>"},{"location":"grpc/#installation","title":"Installation","text":"<p>To use gRPC testing features, enable the <code>grpc</code> feature flag in your <code>Cargo.toml</code>:</p> <pre><code>[dependencies]\ntanu = { version = \"0.17.0\", features = [\"grpc\"] }\ntonic = \"0.12\"  # or your preferred version\ntokio = { version = \"1\", features = [\"full\"] }\n</code></pre>"},{"location":"grpc/#quick-start","title":"Quick Start","text":"<p>The simplest way to get started is using <code>grpc::connect()</code>, which creates a channel with automatic logging enabled:</p> <pre><code>use tanu::{check_eq, eyre, grpc};\n\n#[tanu::test]\nasync fn grpc_unary_call() -&gt; eyre::Result&lt;()&gt; {\n    // Connect with automatic logging\n    let channel = grpc::connect(\"http://localhost:50051\").await?;\n    let mut client = MyServiceClient::new(channel);\n\n    // All gRPC calls are automatically logged\n    let response = client.unary_call(request).await?;\n\n    check_eq!(\"expected\", response.into_inner().message);\n    Ok(())\n}\n</code></pre>"},{"location":"grpc/#using-the-extension-trait","title":"Using the Extension Trait","text":"<p>For more control over channel creation, use the <code>ChannelExt</code> trait to add logging to an existing channel:</p> <pre><code>use tanu::grpc::ChannelExt;\nuse tonic::transport::Channel;\n\n#[tanu::test]\nasync fn with_extension_trait() -&gt; eyre::Result&lt;()&gt; {\n    let channel = Channel::from_static(\"http://localhost:50051\")\n        .connect()\n        .await?\n        .with_tanu_logging();\n\n    let mut client = MyServiceClient::new(channel);\n    let response = client.unary_call(request).await?;\n\n    Ok(())\n}\n</code></pre>"},{"location":"grpc/#captured-data","title":"Captured Data","text":"<p>The gRPC middleware automatically captures the following information for every call:</p> Field Description Example Method Full gRPC method path <code>/echo.Echo/Unary</code> Request Metadata Headers sent to the server <code>x-request-id: 123</code> Response Metadata Headers received from the server <code>x-response-id: 456</code> Status Code gRPC status code <code>OK</code> (0), <code>INVALID_ARGUMENT</code> (3) Status Message Error message (if any) <code>\"missing required field\"</code> Duration Request-to-response time <code>125ms</code> Timestamps Start and end times <code>2026-01-21T10:30:00Z</code> <p>Message Body Limitations</p> <p>Due to gRPC's streaming nature, request and response message bodies are not captured by the middleware. The middleware focuses on metadata, status, and timing information.</p>"},{"location":"grpc/#testing-with-metadata","title":"Testing with Metadata","text":"<p>You can test gRPC calls that require custom metadata:</p> <pre><code>use tonic::{Request, metadata::MetadataValue};\n\n#[tanu::test]\nasync fn test_with_custom_metadata() -&gt; eyre::Result&lt;()&gt; {\n    let channel = grpc::connect(\"http://localhost:50051\").await?;\n    let mut client = EchoClient::new(channel);\n\n    let mut request = Request::new(EchoRequest {\n        message: \"hello\".to_string(),\n    });\n\n    // Add custom metadata\n    request.metadata_mut()\n        .insert(\"x-api-key\", \"secret-key\".parse().unwrap());\n    request.metadata_mut()\n        .insert(\"x-request-id\", \"req-123\".parse().unwrap());\n\n    // Metadata is automatically captured by the middleware\n    let response = client.unary(request).await?;\n\n    check_eq!(\"hello\", response.into_inner().message);\n    Ok(())\n}\n</code></pre>"},{"location":"grpc/#error-handling","title":"Error Handling","text":"<p>The middleware automatically captures error responses with status codes and messages:</p> <pre><code>#[tanu::test]\nasync fn test_invalid_request() -&gt; eyre::Result&lt;()&gt; {\n    let channel = grpc::connect(\"http://localhost:50051\").await?;\n    let mut client = EchoClient::new(channel);\n\n    // This call will fail\n    let result = client.unary(EchoRequest {\n        message: \"\".to_string(),  // Empty message might be invalid\n    }).await;\n\n    // Error is logged automatically with status code and message\n    check!(result.is_err());\n\n    if let Err(status) = result {\n        check_eq!(tonic::Code::InvalidArgument, status.code());\n    }\n\n    Ok(())\n}\n</code></pre>"},{"location":"grpc/#server-streaming","title":"Server Streaming","text":"<p>The middleware works seamlessly with streaming RPCs:</p> <pre><code>use tokio_stream::StreamExt;\n\n#[tanu::test]\nasync fn test_server_streaming() -&gt; eyre::Result&lt;()&gt; {\n    let channel = grpc::connect(\"http://localhost:50051\").await?;\n    let mut client = EchoClient::new(channel);\n\n    // Initial request is logged\n    let mut stream = client.server_stream(EchoStreamRequest {\n        count: 5,\n        message: \"hello\".to_string(),\n    }).await?.into_inner();\n\n    let mut received = 0;\n    while let Some(response) = stream.next().await {\n        let message = response?.message;\n        check_eq!(\"hello\", message);\n        received += 1;\n    }\n\n    check_eq!(5, received);\n    Ok(())\n}\n</code></pre>"},{"location":"grpc/#performance-testing","title":"Performance Testing","text":"<p>Use the captured duration data for performance assertions:</p> <pre><code>#[tanu::test]\nasync fn test_response_time() -&gt; eyre::Result&lt;()&gt; {\n    let channel = grpc::connect(\"http://localhost:50051\").await?;\n    let mut client = EchoClient::new(channel);\n\n    let start = std::time::Instant::now();\n    let response = client.unary(request).await?;\n    let duration = start.elapsed();\n\n    // Assert response time is acceptable\n    check!(duration.as_millis() &lt; 100,\n           \"Response took {}ms, expected &lt; 100ms\",\n           duration.as_millis());\n\n    Ok(())\n}\n</code></pre>"},{"location":"grpc/#best-practices","title":"Best Practices","text":""},{"location":"grpc/#reuse-channels","title":"Reuse Channels","text":"<p>Create channels once and reuse them across multiple test calls:</p> <pre><code>use tokio::sync::OnceCell;\n\nstatic CHANNEL: OnceCell&lt;grpc::LoggingChannel&gt; = OnceCell::const_new();\n\nasync fn get_channel() -&gt; grpc::LoggingChannel {\n    CHANNEL.get_or_init(|| async {\n        grpc::connect(\"http://localhost:50051\")\n            .await\n            .expect(\"Failed to connect\")\n    }).await.clone()\n}\n\n#[tanu::test]\nasync fn test_one() -&gt; eyre::Result&lt;()&gt; {\n    let channel = get_channel().await;\n    let mut client = EchoClient::new(channel);\n    // ...\n    Ok(())\n}\n\n#[tanu::test]\nasync fn test_two() -&gt; eyre::Result&lt;()&gt; {\n    let channel = get_channel().await;\n    let mut client = EchoClient::new(channel);\n    // ...\n    Ok(())\n}\n</code></pre>"},{"location":"grpc/#test-server-errors","title":"Test Server Errors","text":"<p>Always include tests for error scenarios:</p> <pre><code>#[tanu::test]\nasync fn test_missing_required_metadata() -&gt; eyre::Result&lt;()&gt; {\n    let channel = grpc::connect(\"http://localhost:50051\").await?;\n    let mut client = EchoClient::new(channel);\n\n    // Don't add required metadata\n    let err = client.unary(request).await.unwrap_err();\n\n    check_eq!(tonic::Code::InvalidArgument, err.code());\n    check!(err.message().contains(\"missing metadata\"));\n\n    Ok(())\n}\n</code></pre>"},{"location":"grpc/#use-descriptive-method-paths","title":"Use Descriptive Method Paths","text":"<p>The captured method path helps identify which call failed:</p> <pre><code>// The middleware captures: \"/echo.Echo/Unary\"\nlet response = client.unary(request).await?;\n\n// The middleware captures: \"/echo.Echo/ServerStream\"\nlet stream = client.server_stream(request).await?;\n</code></pre>"},{"location":"grpc/#integration-with-tui","title":"Integration with TUI","text":"<p>All captured gRPC calls are visible in the TUI test runner, showing:</p> <ul> <li>Method paths</li> <li>Metadata (request and response)</li> <li>Status codes and messages</li> <li>Response times</li> <li>Timestamps</li> </ul> <p>Run tests in TUI mode to see detailed gRPC call information:</p> <pre><code>cargo run tui\n</code></pre>"},{"location":"grpc/#architecture","title":"Architecture","text":"<p>The gRPC logging feature is built using:</p> <ul> <li>Tower middleware: Wraps Tonic channels with logging layer</li> <li>Event system: Publishes <code>CallLog::Grpc</code> events to the test runner</li> <li>Zero overhead: Logging only activates when tests run with capture enabled</li> </ul> <p>The middleware implementation is in <code>tanu-core/src/grpc.rs</code> and integrates with the existing event-driven test runner architecture.</p>"},{"location":"ordered-execution/","title":"Ordered Test Execution","text":"<p>Ordered tests run in source order within a module. This is useful for setup/verify/cleanup flows where the order of steps matters, while still allowing unrelated tests to run in parallel.</p> <p>Key behavior:</p> <ul> <li>Ordered tests run sequentially within the same module.</li> <li>Order is based on source line number (top to bottom in the file).</li> <li>Different ordered modules can run in parallel.</li> <li>Ordering is project-scoped (the same module in different projects does not block).</li> </ul>"},{"location":"ordered-execution/#module-level-ordering-recommended","title":"Module-level ordering (recommended)","text":"<p>Apply <code>ordered</code> to a module and all <code>#[tanu::test]</code> inside it will run in source order:</p> <pre><code>#[tanu::test(ordered)]\nmod setup_tests {\n    use tanu::eyre;\n\n    #[tanu::test]\n    async fn step_1_init() -&gt; eyre::Result&lt;()&gt; {\n        Ok(())\n    }\n\n    #[tanu::test]\n    async fn step_2_setup() -&gt; eyre::Result&lt;()&gt; {\n        Ok(())\n    }\n\n    #[tanu::test]\n    async fn step_3_verify() -&gt; eyre::Result&lt;()&gt; {\n        Ok(())\n    }\n\n    #[tanu::test]\n    async fn step_4_cleanup() -&gt; eyre::Result&lt;()&gt; {\n        Ok(())\n    }\n}\n</code></pre> <p>Reordering the functions in the file changes the execution order.</p>"},{"location":"ordered-execution/#interaction-with-serial-groups","title":"Interaction with serial groups","text":"<p><code>ordered</code> implies a per-module serial group (based on <code>module_path!()</code>), so tests in the same ordered module are serialized. If you also specify <code>serial</code>, the ordered grouping takes precedence. Prefer not to combine them.</p>"},{"location":"ordered-execution/#parallelism-and-concurrency","title":"Parallelism and concurrency","text":"<p>Ordered groups only serialize tests within the same module. Different ordered modules and non-ordered tests still run in parallel, subject to the configured concurrency limit.</p>"},{"location":"report/","title":"Allure Reports","text":""},{"location":"report/#overview","title":"Overview","text":"<p><code>tanu</code> integrates with the tanu-allure reporter, which emits Allure-compatible JSON for each executed test. The reporter plugs into <code>tanu_core::Reporter</code>, so HTTP calls, assertions, and timings automatically flow into Allure dashboards without extra plumbing. See https://github.com/tanu-rs/tanu-allure for more information.</p> <p></p>"},{"location":"tags/","title":"Tags","text":"<p>Browse documentation by topic:</p> <p>[TAGS]</p>"},{"location":"tags/#available-tags","title":"Available Tags","text":"<ul> <li>HTTP - HTTP client features, requests, and responses</li> <li>Testing - Test attributes, assertions, and best practices  </li> <li>Configuration - Project configuration and environment setup</li> <li>API - API reference and usage examples</li> <li>Rust - Rust-specific features and patterns</li> </ul>"},{"location":"tui/","title":"TUI","text":"<p>In TUI mode, you can select and execute a test case and see the result more interactively.</p> <p></p>"},{"location":"tui/#commands","title":"Commands","text":""},{"location":"tui/#navigation","title":"Navigation","text":"<ul> <li><code>Tab</code>: Switch between panes</li> <li><code>\u2192</code>: Navigate to next pane</li> <li><code>\u2190</code>: Navigate to previous pane</li> <li><code>\u2191</code>: Move cursor up</li> <li><code>\u2193</code>: Move cursor down</li> <li><code>Enter</code>: Expand/collapse project, module or test case in the list</li> </ul>"},{"location":"tui/#scrolling","title":"Scrolling","text":"<ul> <li><code>CTRL+U</code>: Scroll up half the screen</li> <li><code>CTRL+D</code>: Scroll down half the screen</li> <li><code>g</code>: Scroll to the top of the screen</li> <li><code>G</code>: Scroll to the bottom of the screen</li> </ul>"},{"location":"tui/#test-operations","title":"Test Operations","text":"<ul> <li><code>1</code>: Run all test cases</li> <li><code>2</code>: Run only the selected test cases</li> <li><code>Space</code>: Mark/unmark a test case for selection (use with <code>2</code> to run selected tests)</li> </ul>"},{"location":"tui/#view-control","title":"View Control","text":"<ul> <li><code>z</code>: Maximize/minimize the current pane</li> <li><code>?</code>: Show help panel with available commands</li> </ul>"},{"location":"tui/#general","title":"General","text":"<ul> <li><code>q</code>: Quit the TUI mode</li> <li><code>Esc</code>: Cancel current operation or close modal dialogs</li> </ul>"},{"location":"tui/#tips","title":"Tips","text":"<ul> <li>Use keyboard navigation to quickly move between test cases</li> <li>Maximize a pane with <code>z</code> when you need to see more details</li> <li>Mark multiple tests with <code>Space</code> before executing them with <code>2</code></li> </ul>"}]}