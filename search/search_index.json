{"config":{"lang":["en"],"separator":"[\\s\\-,:!=\\[\\]()\"`/]+|\\.(?!\\d)|&[lg]t;|(?!\\b)(?=[A-Z][a-z])","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Welcome","text":"<p>tanu: high-performance, async-friendly and ergonomic WebAPI testing framework for Rust</p> <p> </p>"},{"location":"#motivation","title":"Motivation","text":"<p>As a long time backend engineer, I have always been passionate about building reliable and efficient systems. When working with WebAPIs, ensuring correctness, stability, and performance is crucial, yet I often found existing testing frameworks lacking in speed, flexibility, or Rust-native support. This led me to create a WebAPI testing framework in Rust.</p> <p>While some WebAPI testing tools exist for Rust, they often lack ergonomics, are too low-level, or don't integrate well with modern Rust web frameworks. My goal was to create a framework that is:</p> <ul> <li>Fast and lightweight \u2013 Leveraging Rust\u2019s zero-cost abstractions to minimize unnecessary overhead.</li> <li>Type-safe and ergonomic \u2013 Taking advantage of Rust\u2019s strong type system to prevent common errors at compile time.</li> <li>Easily extensible \u2013 Allowing developers to integrate custom assertions, mocking, and performance metrics seamlessly.</li> <li>Concurrency and async-friendly \u2013 Supporting asynchronous requests and concurrent execution to test APIs efficiently.</li> </ul> <p>I tried multiple solutions in the past but encountered significant limitations:</p> <ul> <li>Postman - Postman is a great tool but not designed for API end-to-end testing. You need a GUI and have to write assertions in JavaScript, which results in massive JSON files that become difficult to manage.</li> <li>Playwright - Playwright is an excellent framework for web end-to-end testing. While it does support API testing, I wanted to use the same language for both API implementation and tests, which Playwright does not offer.</li> <li>Rust Standard Test Framework - I attempted multiple times to write API tests using <code>#[test]</code>, along with tokio, test-case, and reqwest crates. While functional, this approach lacked structure and ergonomics for writing effective tests at scale. I wanted a dedicated framework to simplify and streamline the process.</li> </ul>"},{"location":"#writing-tests-with-tanu","title":"Writing Tests with Tanu","text":"<p>Writing API tests with tanu is designed to be intuitive and ergonomic. Here's what a typical test looks like:</p> <pre><code>use tanu::{check, check_eq, eyre, http::Client};\n\n#[tanu::test]\nasync fn get_user_profile() -&gt; eyre::Result&lt;()&gt; {\n    let client = Client::new();\n\n    // Make HTTP request\n    let response = client\n        .get(\"https://api.example.com/users/123\")\n        .header(\"authorization\", \"Bearer token123\")\n        .send()\n        .await?;\n\n    // Verify response\n    check!(response.status().is_success(), \"Expected successful response\");\n\n    // Parse and validate JSON\n    let user: serde_json::Value = response.json().await?;\n    check_eq!(123, user[\"id\"].as_i64().unwrap());\n    check_eq!(\"John Doe\", user[\"name\"].as_str().unwrap());\n\n    Ok(())\n}\n\n// Parameterized tests for testing multiple scenarios\n#[tanu::test(200)]\n#[tanu::test(404)]\n#[tanu::test(500)]\nasync fn test_status_codes(expected_status: u16) -&gt; eyre::Result&lt;()&gt; {\n    let client = Client::new();\n    let response = client\n        .get(&amp;format!(\"https://httpbin.org/status/{expected_status}\"))\n        .send()\n        .await?;\n\n    check_eq!(expected_status, response.status().as_u16());\n    Ok(())\n}\n\n#[tanu::main]\n#[tokio::main]\nasync fn main() -&gt; eyre::Result&lt;()&gt; {\n    let runner = run();\n    let app = tanu::App::new();\n    app.run(runner).await?;\n    Ok(())\n}\n</code></pre>"},{"location":"#key-features-highlighted","title":"Key Features Highlighted:","text":"<ul> <li>Simple and Clean: Tests look like regular Rust functions with the <code>#[tanu::test]</code> attribute</li> <li>Async/Await Native: Full support for async operations without boilerplate</li> <li>Type-Safe: Leverage Rust's type system for robust API testing</li> <li>Ergonomic Assertions: Use <code>check!</code>, <code>check_eq!</code>, and other assertion macros for clear test validation</li> <li>Parameterized Testing: Test multiple scenarios with different inputs using multiple <code>#[tanu::test(param)]</code> attributes</li> <li>Built-in HTTP Client: No need to set up reqwest or other HTTP clients manually</li> <li>Error Handling: Clean error propagation with <code>eyre::Result</code></li> </ul>"},{"location":"#screenshots","title":"Screenshots","text":""},{"location":"#contributors","title":"Contributors","text":"<p>Thanks to all the amazing people who have contributed to making tanu better! Every contribution, big or small, helps build a more robust and feature-rich testing framework for the Rust community \u2728</p> <p> </p> <p>Made with contrib.rocks.</p>"},{"location":"#acknowledgments","title":"Acknowledgments","text":"<p>We're grateful to our sponsors who support the development of tanu:</p> <sub>yuk1ty</sub>  \ud83d\udc36  <sub>2323-code</sub>  \ud83e\udd69  <p>Your support helps make tanu better for everyone. Thank you! \ud83d\ude4f</p>"},{"location":"#license","title":"License","text":"<p>This project is licensed under the Apache License 2.0 - see the LICENSE file for details.</p> <p>The Apache License 2.0 is a permissive open source license that allows you to: - Use the software for any purpose - Distribute it - Modify it - Distribute modified versions - Place warranty</p> <p>For more information about the Apache License 2.0, visit: http://www.apache.org/licenses/LICENSE-2.0</p>"},{"location":"assertion/","title":"Assertions","text":"<p>Tanu provides a comprehensive assertion system designed specifically for WebAPI testing. The assertion macros follow similar signatures to Rust's standard <code>assert!</code> macros but are tailored for testing environments with enhanced error reporting and colored output.</p>"},{"location":"assertion/#key-features","title":"Key Features","text":"<ul> <li>Error-based instead of panic-based: Returns <code>eyre::Result</code> instead of panicking</li> <li>Colored output: Uses <code>pretty_assertions</code> for beautiful diff visualization</li> <li>Event publishing: Publishes test results to the tanu runner for reporting</li> <li>Async-friendly: Works seamlessly with async test functions</li> </ul>"},{"location":"assertion/#available-macros","title":"Available Macros","text":""},{"location":"assertion/#check","title":"<code>check!</code>","text":"<p>Basic assertion macro that validates a boolean condition.</p> <pre><code>use tanu::check;\n\n#[tanu::test]\nasync fn basic_check() -&gt; eyre::Result&lt;()&gt; {\n    check!(true);\n    check!(2 + 2 == 4);\n    check!(response.status().is_success(), \"Expected successful response\");\n    Ok(())\n}\n</code></pre> <p>Signatures: - <code>check!(condition)</code> - Simple boolean check - <code>check!(condition, message, args...)</code> - With custom error message</p>"},{"location":"assertion/#check_eq","title":"<code>check_eq!</code>","text":"<p>Asserts that two values are equal, with pretty-printed diff output for mismatches.</p> <pre><code>use tanu::check_eq;\n\n#[tanu::test]\nasync fn equality_check() -&gt; eyre::Result&lt;()&gt; {\n    check_eq!(200, response.status().as_u16());\n    check_eq!(\"application/json\", response.headers().get(\"content-type\"));\n    check_eq!(expected_payload, actual_payload, \"Response payload mismatch\");\n    Ok(())\n}\n</code></pre> <p>Signatures: - <code>check_eq!(left, right)</code> - Basic equality check - <code>check_eq!(left, right, message, args...)</code> - With custom error message</p>"},{"location":"assertion/#check_ne","title":"<code>check_ne!</code>","text":"<p>Asserts that two values are not equal.</p> <pre><code>use tanu::check_ne;\n\n#[tanu::test]\nasync fn inequality_check() -&gt; eyre::Result&lt;()&gt; {\n    check_ne!(404, response.status().as_u16());\n    check_ne!(\"\", response.body());\n    Ok(())\n}\n</code></pre> <p>Signatures: - <code>check_ne!(left, right)</code> - Basic inequality check - <code>check_ne!(left, right, message, args...)</code> - With custom error message</p>"},{"location":"assertion/#check_str_eq","title":"<code>check_str_eq!</code>","text":"<p>Specialized string equality assertion with enhanced string comparison visualization.</p> <pre><code>use tanu::check_str_eq;\n\n#[tanu::test]\nasync fn string_check() -&gt; eyre::Result&lt;()&gt; {\n    check_str_eq!(\"expected\", actual_string);\n    check_str_eq!(expected_json, response.text().await?, \"JSON response mismatch\");\n    Ok(())\n}\n</code></pre> <p>Signatures: - <code>check_str_eq!(left, right)</code> - Basic string equality check - <code>check_str_eq!(left, right, message, args...)</code> - With custom error message</p>"},{"location":"assertion/#key-differences-from-standard-assert","title":"Key Differences from Standard <code>assert!</code>","text":"Feature Standard <code>assert!</code> Tanu <code>check!</code> Error handling Panics on failure Returns <code>eyre::Result</code> Output format Basic text Colored with <code>pretty_assertions</code> Integration Standalone Publishes events to tanu runner Async support Limited Full async/await support Macro naming <code>assert!</code>, <code>assert_eq!</code>, <code>assert_ne!</code> <code>check!</code>, <code>check_eq!</code>, <code>check_ne!</code>, <code>check_str_eq!</code>"},{"location":"assertion/#error-handling","title":"Error Handling","text":"<p>All assertion macros return <code>eyre::Result</code> types, making them compatible with async test functions that return <code>Result</code> types. When an assertion fails:</p> <ol> <li>An error event is published to the tanu runner</li> <li>An <code>eyre::Report</code> is generated with detailed context</li> <li>The error is propagated up the call stack</li> <li>Tanu displays colored backtraces and error information</li> </ol>"},{"location":"assertion/#examples","title":"Examples","text":""},{"location":"assertion/#http-response-testing","title":"HTTP Response Testing","text":"<pre><code>use tanu::{check, check_eq, check_ne, eyre, http::Client};\n\n#[tanu::test]\nasync fn api_test() -&gt; eyre::Result&lt;()&gt; {\n    let client = Client::new();\n    let response = client\n        .get(\"https://api.example.com/users\")\n        .send()\n        .await?;\n\n    // Check status code\n    check!(response.status().is_success(), \"API request failed\");\n    check_eq!(200, response.status().as_u16());\n\n    // Check headers\n    check_ne!(\"\", response.headers().get(\"content-type\").unwrap());\n\n    // Check response body\n    let users: Vec&lt;User&gt; = response.json().await?;\n    check!(!users.is_empty(), \"Expected non-empty user list\");\n\n    Ok(())\n}\n</code></pre>"},{"location":"assertion/#json-response-validation","title":"JSON Response Validation","text":"<pre><code>use tanu::{check_eq, check_str_eq, eyre, http::Client};\nuse serde_json::Value;\n\n#[tanu::test]\nasync fn json_validation() -&gt; eyre::Result&lt;()&gt; {\n    let client = Client::new();\n    let response = client\n        .get(\"https://api.example.com/config\")\n        .send()\n        .await?;\n\n    let json: Value = response.json().await?;\n\n    check_eq!(\"v1.0\", json[\"version\"].as_str().unwrap());\n    check_str_eq!(\"production\", json[\"environment\"].as_str().unwrap());\n\n    Ok(())\n}\n</code></pre>"},{"location":"assertion/#best-practices","title":"Best Practices","text":"<ol> <li> <p>Use descriptive messages: Always provide context for assertion failures    <pre><code>check!(response.status().is_success(), \"Failed to authenticate user\");\n</code></pre></p> </li> <li> <p>Choose the right assertion: Use <code>check_str_eq!</code> for string comparisons to get better diff output    <pre><code>// Good\ncheck_str_eq!(expected_json, actual_json);\n\n// Less helpful output\ncheck_eq!(expected_json, actual_json);\n</code></pre></p> </li> <li> <p>Combine with HTTP utilities: Leverage tanu's HTTP client for comprehensive API testing    <pre><code>let response = client.post(\"/api/login\")\n    .json(&amp;credentials)\n    .send()\n    .await?;\n\ncheck!(response.status().is_success(), \"Login failed\");\n</code></pre></p> </li> <li> <p>Handle async properly: All assertions work seamlessly in async contexts    <pre><code>#[tanu::test]\nasync fn async_test() -&gt; eyre::Result&lt;()&gt; {\n    let result = some_async_operation().await?;\n    check!(result.is_valid());\n    Ok(())\n}\n</code></pre></p> </li> </ol>"},{"location":"assertion/#error-output","title":"Error Output","text":"<p>When assertions fail, tanu provides rich error information:</p> <pre><code>check failed: `(left == right)`: Expected status code 200\n\n   left: 404\n  right: 200\n\nError: check failed: `(left == right)`: Expected status code 200\n</code></pre> <p>For string comparisons, you get detailed diff output highlighting the differences between expected and actual values.</p>"},{"location":"attribute/","title":"<code>#[tanu::test]</code> Attribute","text":"<p>The <code>#[tanu::test]</code> attribute is used to mark functions as test functions in the Tanu framework. When a function is annotated with this attribute, it will be executed as part of the test suite.</p>"},{"location":"attribute/#usage","title":"Usage","text":"<p>To use the <code>#[tanu::test]</code> attribute, simply add it above the function definition:</p> <pre><code>use tanu::check_eq;\n\n#[tanu::test]\nasync fn my_test_function() -&gt; eyre::Result&lt;()&gt; {\n    let result = 2 + 2;\n    check_eq!(result, 4);\n    Ok(())\n}\n</code></pre> <p>Notes * The #[tanu::test] attribute can only be applied to \"async\" functions. * Functions marked with #[tanu::test] should not take any arguments and should not return any values. * The tanu framework will automatically discover and run all functions marked with the <code>#[tanu::test]</code> attribute when the test suite is executed.</p>"},{"location":"attribute/#parameterized-tests","title":"Parameterized Tests","text":"<p><code>#[tanu::test]</code> attribute is inspired by test_case crate where you can easily parameterize test case by providing parameters in the attribute body as follows.</p> <pre><code>use tanu::check_eq;\n\n#[tanu::test(10, 10, 20)]\n#[tanu::test(20, 20, 40)]\nasync fn my_test_function(a: u32, b: u32, expected: u32) -&gt; eyre::Result&lt;()&gt; {\n    let result = a + b;\n    check_eq!(result, expected);\n    Ok(())\n}\n</code></pre> <p>If you run a parameterized test, the test name will be automatically generated by concatenating the stringified parameters, resulting in <code>my_test_function_10_10_20</code>.</p> <p>Sometimes parameters can't be strigified, in such case, tanu refuse to compile the code. In such cases, tanu refuses to compile the code. If that happens, you can specify your desired name rather than the auto-generated one. Note that a test name is delimited by <code>;</code> from the parameters.</p> <pre><code>use tanu::check_eq;\n\n#[tanu::test(10, 10, 20; \"add_10_and_10_equal_20\")]\n#[tanu::test(20, 20, 40; \"add_20_and_20_equal_40\")]\nasync fn my_test_function(a: u32, b: u32, expected: u32) -&gt; eyre::Result&lt;()&gt; {\n    let result = a + b;\n    check_eq!(result, expected);\n    Ok(())\n}\n</code></pre>"},{"location":"best-practices/","title":"Best Practices","text":"<p>tags:   - Testing   - HTTP   - Configuration</p> <p>This guide covers best practices for writing effective API tests with tanu, based on real-world experience and established patterns.</p>"},{"location":"best-practices/#test-organization","title":"Test Organization","text":""},{"location":"best-practices/#use-descriptive-test-names","title":"Use Descriptive Test Names","text":"<p>Choose test names that clearly describe what is being tested:</p> <pre><code>// Good\n#[tanu::test]\nasync fn get_user_returns_valid_profile_data() -&gt; eyre::Result&lt;()&gt; { ... }\n\n#[tanu::test]\nasync fn create_user_with_invalid_email_returns_400() -&gt; eyre::Result&lt;()&gt; { ... }\n\n// Less clear\n#[tanu::test]\nasync fn test_user() -&gt; eyre::Result&lt;()&gt; { ... }\n\n#[tanu::test]\nasync fn user_test_2() -&gt; eyre::Result&lt;()&gt; { ... }\n</code></pre>"},{"location":"best-practices/#group-related-tests-in-modules","title":"Group Related Tests in Modules","text":"<p>Organize tests by feature or endpoint:</p> <pre><code>// src/tests/user.rs\nmod user {\n    #[tanu::test]\n    async fn create_user_success() -&gt; eyre::Result&lt;()&gt; { ... }\n\n    #[tanu::test]\n    async fn get_user_profile() -&gt; eyre::Result&lt;()&gt; { ... }\n\n    #[tanu::test]\n    async fn update_user_profile() -&gt; eyre::Result&lt;()&gt; { ... }\n}\n\n// src/tests/auth.rs\nmod auth {\n    #[tanu::test]\n    async fn login_with_valid_credentials() -&gt; eyre::Result&lt;()&gt; { ... }\n\n    #[tanu::test]\n    async fn login_with_invalid_credentials() -&gt; eyre::Result&lt;()&gt; { ... }\n}\n</code></pre>"},{"location":"best-practices/#http-best-practices","title":"HTTP Best Practices","text":""},{"location":"best-practices/#check-response-headers-with-original-casing","title":"Check Response Headers with Original Casing","text":"<p>When validating response headers, use the casing returned by the server:</p> <pre><code>let response: HeadersResponse = res.json().await?;\n\n// Server returns headers with original casing\ncheck!(response.headers.contains_key(\"Content-Type\"));\ncheck!(response.headers.contains_key(\"X-Custom-Header\"));\n</code></pre>"},{"location":"best-practices/#handle-errors-gracefully","title":"Handle Errors Gracefully","text":"<p>Always handle potential HTTP errors:</p> <pre><code>#[tanu::test]\nasync fn robust_api_test() -&gt; eyre::Result&lt;()&gt; {\n    let client = Client::new();\n\n    let response = client\n        .get(\"https://api.example.com/users/123\")\n        .send()\n        .await?;\n\n    // Check status before processing response\n    check!(response.status().is_success(), \n           \"Expected successful response, got: {}\", response.status());\n\n    // Handle potential JSON parsing errors\n    let user: serde_json::Value = response.json().await\n        .map_err(|e| eyre::eyre!(\"Failed to parse JSON response: {}\", e))?;\n\n    Ok(())\n}\n</code></pre>"},{"location":"best-practices/#parameterized-testing","title":"Parameterized Testing","text":""},{"location":"best-practices/#use-parameterized-tests-for-similar-scenarios","title":"Use Parameterized Tests for Similar Scenarios","text":"<p>Instead of duplicating test logic, use parameterized tests:</p> <pre><code>// Good - Single test function with multiple parameters\n#[tanu::test(200)]\n#[tanu::test(404)]\n#[tanu::test(500)]\nasync fn test_status_endpoints(status_code: u16) -&gt; eyre::Result&lt;()&gt; {\n    let client = Client::new();\n    let response = client\n        .get(&amp;format!(\"https://httpbin.org/status/{status_code}\"))\n        .send()\n        .await?;\n\n    check_eq!(status_code, response.status().as_u16());\n    Ok(())\n}\n\n// Less efficient - Separate functions for each test case\n#[tanu::test]\nasync fn test_200_status() -&gt; eyre::Result&lt;()&gt; { ... }\n\n#[tanu::test]\nasync fn test_404_status() -&gt; eyre::Result&lt;()&gt; { ... }\n\n#[tanu::test]\nasync fn test_500_status() -&gt; eyre::Result&lt;()&gt; { ... }\n</code></pre>"},{"location":"best-practices/#choose-meaningful-parameter-values","title":"Choose Meaningful Parameter Values","text":"<p>Select parameter values that represent real-world scenarios:</p> <pre><code>// Good - Realistic delay values\n#[tanu::test(1)]\n#[tanu::test(2)]\n#[tanu::test(5)]\nasync fn test_api_timeout_handling(delay_seconds: u64) -&gt; eyre::Result&lt;()&gt; { ... }\n\n// Good - Common HTTP status codes\n#[tanu::test(400)]  // Bad Request\n#[tanu::test(401)]  // Unauthorized  \n#[tanu::test(403)]  // Forbidden\n#[tanu::test(404)]  // Not Found\nasync fn test_error_responses(status_code: u16) -&gt; eyre::Result&lt;()&gt; { ... }\n</code></pre>"},{"location":"best-practices/#assertions","title":"Assertions","text":""},{"location":"best-practices/#use-specific-assertion-macros","title":"Use Specific Assertion Macros","text":"<p>Choose the most appropriate assertion macro for better error messages:</p> <pre><code>// Good - Specific assertions\ncheck_eq!(expected_id, user[\"id\"].as_i64().unwrap());\ncheck_ne!(0, response.headers().len());\ncheck!(response.status().is_success());\n\n// Less informative\ncheck!(user[\"id\"].as_i64().unwrap() == expected_id);\ncheck!(response.headers().len() &gt; 0);\ncheck!(response.status().as_u16() &gt;= 200 &amp;&amp; response.status().as_u16() &lt; 300);\n</code></pre>"},{"location":"best-practices/#provide-descriptive-error-messages","title":"Provide Descriptive Error Messages","text":"<p>Add context to your assertions:</p> <pre><code>check!(response.status().is_success(), \n       \"API should return success status, got: {} - {}\", \n       response.status(), \n       response.text().await?);\n\ncheck_eq!(expected_name, user[\"name\"].as_str().unwrap(),\n          \"User name should match expected value\");\n</code></pre>"},{"location":"best-practices/#validate-response-structure","title":"Validate Response Structure","text":"<p>Don't just check status codes - validate the actual response data:</p> <pre><code>#[tanu::test]\nasync fn get_user_returns_complete_profile() -&gt; eyre::Result&lt;()&gt; {\n    let response = client.get(\"/users/123\").send().await?;\n    check!(response.status().is_success());\n\n    let user: serde_json::Value = response.json().await?;\n\n    // Validate required fields exist\n    check!(user[\"id\"].is_number(), \"User ID should be a number\");\n    check!(user[\"name\"].is_string(), \"User name should be a string\");\n    check!(user[\"email\"].is_string(), \"User email should be a string\");\n    check!(user[\"created_at\"].is_string(), \"Created date should be present\");\n\n    // Validate field values\n    check_eq!(123, user[\"id\"].as_i64().unwrap());\n    check!(!user[\"name\"].as_str().unwrap().is_empty(), \"Name should not be empty\");\n\n    Ok(())\n}\n</code></pre>"},{"location":"best-practices/#use-serde-for-type-safe-response-validation","title":"Use Serde for Type-Safe Response Validation","text":"<p>Instead of manually parsing JSON, define response structures with serde for better type safety and automatic validation:</p> <pre><code>use serde::Deserialize;\n\n#[derive(Debug, Deserialize)]\nstruct User {\n    id: i64,\n    name: String,\n    email: String,\n    verified: bool,\n    created_at: String,\n}\n\n#[derive(Debug, Deserialize)]\nstruct CreateUserResponse {\n    user: User,\n    message: String,\n}\n\n#[tanu::test]\nasync fn create_user_with_serde_validation() -&gt; eyre::Result&lt;()&gt; {\n    let user_data = serde_json::json!({\n        \"name\": \"John Doe\",\n        \"email\": \"john@example.com\"\n    });\n\n    let response = client\n        .post(\"/users\")\n        .json(&amp;user_data)\n        .send()\n        .await?;\n\n    check!(response.status().is_success());\n\n    // Serde automatically validates the response structure\n    let create_response: CreateUserResponse = response.json().await\n        .map_err(|e| eyre::eyre!(\"Failed to parse response: {}\", e))?;\n\n    // Type-safe field access\n    check_eq!(\"John Doe\", create_response.user.name);\n    check_eq!(\"john@example.com\", create_response.user.email);\n    check!(!create_response.user.verified); // New users start unverified\n    check!(!create_response.message.is_empty());\n\n    Ok(())\n}\n</code></pre> <p>Benefits of using serde: - Compile-time safety: Field names and types are checked at compile time - Automatic validation: Serde will fail if required fields are missing or have wrong types - Better error messages: Clear errors when deserialization fails - Documentation: Struct definitions serve as API documentation - Refactoring safety: Changes to field names are caught by the compiler</p> <p>Optional fields and error handling: <pre><code>#[derive(Debug, Deserialize)]\nstruct UserProfile {\n    id: i64,\n    name: String,\n    email: String,\n    #[serde(default)]\n    avatar_url: Option&lt;String&gt;,\n    #[serde(rename = \"created_at\")]\n    created_date: String,\n}\n\n#[tanu::test]\nasync fn handle_optional_fields_with_serde() -&gt; eyre::Result&lt;()&gt; {\n    let response = client.get(\"/users/123\").send().await?;\n    check!(response.status().is_success());\n\n    let user: UserProfile = response.json().await?;\n\n    // Required fields are guaranteed to exist\n    check_eq!(123, user.id);\n    check!(!user.name.is_empty());\n\n    // Optional fields can be safely checked\n    if let Some(avatar) = user.avatar_url {\n        check!(avatar.starts_with(\"https://\"));\n    }\n\n    Ok(())\n}\n</code></pre></p>"},{"location":"best-practices/#configuration-management","title":"Configuration Management","text":""},{"location":"best-practices/#use-environment-specific-configurations","title":"Use Environment-Specific Configurations","text":"<p>Create separate configurations for different environments:</p> <pre><code># tanu.toml\n[[projects]]\nname = \"local\"\nbase_url = \"http://localhost:8080\"\ntimeout = 5000\n\n[[projects]]\nname = \"staging\"\nbase_url = \"https://staging.api.example.com\"\ntimeout = 10000\nretry.count = 2\n\n[[projects]]\nname = \"production\" \nbase_url = \"https://api.example.com\"\ntimeout = 15000\nretry.count = 3\nretry.factor = 2.0\n</code></pre>"},{"location":"best-practices/#ignore-flaky-or-slow-tests-appropriately","title":"Ignore Flaky or Slow Tests Appropriately","text":"<p>Use test_ignore for tests that shouldn't run in certain environments:</p> <pre><code>[[projects]]\nname = \"ci\"\ntest_ignore = [\n    \"slow_integration_test\",\n    \"external_dependency_test\",\n    \"load_test\"\n]\n</code></pre>"},{"location":"best-practices/#performance-considerations","title":"Performance Considerations","text":""},{"location":"best-practices/#minimize-test-dependencies","title":"Minimize Test Dependencies","text":"<p>Keep tests isolated and avoid dependencies between test cases:</p> <pre><code>// Good - Each test is independent\n#[tanu::test]\nasync fn create_user_test() -&gt; eyre::Result&lt;()&gt; {\n    // Create test data\n    // Run test\n    // Clean up (if needed)\n    Ok(())\n}\n\n// Avoid - Tests depending on each other\n#[tanu::test]\nasync fn create_user_first() -&gt; eyre::Result&lt;()&gt; { ... }\n\n#[tanu::test] \nasync fn update_user_created_above() -&gt; eyre::Result&lt;()&gt; {\n    // This test depends on the previous test\n    Ok(())\n}\n</code></pre>"},{"location":"best-practices/#use-appropriate-timeouts","title":"Use Appropriate Timeouts","text":"<p>Configure timeouts based on expected response times:</p> <pre><code>let response = client\n    .get(\"https://api.example.com/slow-endpoint\")\n    .timeout(Duration::from_secs(30))  // Adjust based on endpoint\n    .send()\n    .await?;\n</code></pre>"},{"location":"best-practices/#batch-related-assertions","title":"Batch Related Assertions","text":"<p>Group related assertions together to minimize API calls:</p> <pre><code>#[tanu::test]\nasync fn validate_user_profile_completely() -&gt; eyre::Result&lt;()&gt; {\n    let response = client.get(\"/users/123\").send().await?;\n    let user: serde_json::Value = response.json().await?;\n\n    // Multiple assertions on the same response\n    check_eq!(123, user[\"id\"].as_i64().unwrap());\n    check_eq!(\"John Doe\", user[\"name\"].as_str().unwrap());\n    check_eq!(\"john@example.com\", user[\"email\"].as_str().unwrap());\n    check!(user[\"verified\"].as_bool().unwrap());\n\n    Ok(())\n}\n</code></pre>"},{"location":"best-practices/#security-best-practices","title":"Security Best Practices","text":""},{"location":"best-practices/#dont-hardcode-sensitive-data","title":"Don't Hardcode Sensitive Data","text":"<p>Use environment variables or configuration for sensitive information:</p> <pre><code>// Good\nlet api_key = std::env::var(\"API_KEY\")\n    .map_err(|_| eyre::eyre!(\"API_KEY environment variable not set\"))?;\n\nlet response = client\n    .get(\"https://api.example.com/protected\")\n    .header(\"authorization\", format!(\"Bearer {}\", api_key))\n    .send()\n    .await?;\n\n// Avoid\nlet response = client\n    .get(\"https://api.example.com/protected\")\n    .header(\"authorization\", \"Bearer sk-1234567890abcdef\")  // Hardcoded!\n    .send()\n    .await?;\n</code></pre>"},{"location":"best-practices/#validate-ssl-certificates","title":"Validate SSL Certificates","text":"<p>Ensure your tests validate SSL certificates in production environments (this is the default behavior).</p>"},{"location":"best-practices/#use-https-in-production-tests","title":"Use HTTPS in Production Tests","text":"<p>Always use HTTPS endpoints when testing production or staging environments.</p>"},{"location":"best-practices/#error-handling","title":"Error Handling","text":""},{"location":"best-practices/#use-meaningful-error-messages","title":"Use Meaningful Error Messages","text":"<p>Provide context when tests fail:</p> <pre><code>#[tanu::test]\nasync fn comprehensive_error_handling() -&gt; eyre::Result&lt;()&gt; {\n    let response = client\n        .post(\"https://api.example.com/users\")\n        .json(&amp;user_data)\n        .send()\n        .await\n        .map_err(|e| eyre::eyre!(\"Failed to send request to create user: {}\", e))?;\n\n    if !response.status().is_success() {\n        let error_body = response.text().await?;\n        return Err(eyre::eyre!(\n            \"User creation failed with status {}: {}\", \n            response.status(), \n            error_body\n        ));\n    }\n\n    Ok(())\n}\n</code></pre>"},{"location":"best-practices/#handle-rate-limiting","title":"Handle Rate Limiting","text":"<p>Be respectful of API rate limits:</p> <pre><code>use tokio::time::{sleep, Duration};\n\n#[tanu::test]\nasync fn rate_limited_test() -&gt; eyre::Result&lt;()&gt; {\n    for i in 0..10 {\n        let response = client.get(\"/api/endpoint\").send().await?;\n\n        if response.status().as_u16() == 429 {\n            // Rate limited, wait before retrying\n            sleep(Duration::from_secs(1)).await;\n            continue;\n        }\n\n        check!(response.status().is_success());\n\n        // Small delay between requests\n        if i &lt; 9 {\n            sleep(Duration::from_millis(100)).await;\n        }\n    }\n\n    Ok(())\n}\n</code></pre>"},{"location":"best-practices/#maintenance","title":"Maintenance","text":""},{"location":"best-practices/#keep-tests-up-to-date","title":"Keep Tests Up to Date","text":"<p>Regularly review and update tests as APIs evolve:</p> <ul> <li>Update endpoint URLs when they change</li> <li>Modify assertions when response formats change  </li> <li>Add tests for new API features</li> <li>Remove tests for deprecated functionality</li> </ul>"},{"location":"best-practices/#document-complex-test-logic","title":"Document Complex Test Logic","text":"<p>Add comments for complex test scenarios:</p> <pre><code>#[tanu::test]\nasync fn complex_workflow_test() -&gt; eyre::Result&lt;()&gt; {\n    // Step 1: Create user account\n    let user_response = client.post(\"/users\").json(&amp;user_data).send().await?;\n    let user_id = user_response.json::&lt;serde_json::Value&gt;().await?[\"id\"].as_i64().unwrap();\n\n    // Step 2: Verify email (simulated)\n    client.post(&amp;format!(\"/users/{}/verify\", user_id)).send().await?;\n\n    // Step 3: Login with verified account\n    let login_response = client\n        .post(\"/auth/login\")\n        .json(&amp;login_data)\n        .send()\n        .await?;\n\n    check!(login_response.status().is_success(), \"Login should succeed after verification\");\n\n    Ok(())\n}\n</code></pre>"},{"location":"best-practices/#regular-cleanup","title":"Regular Cleanup","text":"<ul> <li>Remove obsolete tests</li> <li>Consolidate duplicate test logic</li> <li>Update dependencies regularly</li> <li>Review and update configuration files</li> </ul>"},{"location":"best-practices/#result-type-flexibility","title":"Result Type Flexibility","text":"<p>Tanu supports various Result types, allowing you to choose the error handling approach that best fits your needs:</p> <pre><code>// eyre::Result (recommended)\n#[tanu::test]\nasync fn test_with_eyre() -&gt; eyre::Result&lt;()&gt; {\n    let response = client.get(\"/api/endpoint\").send().await?;\n    check!(response.status().is_success());\n    Ok(())\n}\n\n// anyhow::Result  \n#[tanu::test]\nasync fn test_with_anyhow() -&gt; anyhow::Result&lt;()&gt; {\n    let response = client.get(\"/api/endpoint\").send().await\n        .map_err(|e| anyhow::anyhow!(\"Request failed: {}\", e))?;\n\n    if !response.status().is_success() {\n        return Err(anyhow::anyhow!(\"Expected success, got: {}\", response.status()));\n    }\n    Ok(())\n}\n\n// Custom error types\n#[derive(Debug)]\nenum ApiError {\n    Network(String),\n    InvalidResponse(String),\n}\n\nimpl std::fmt::Display for ApiError {\n    fn fmt(&amp;self, f: &amp;mut std::fmt::Formatter&lt;'_&gt;) -&gt; std::fmt::Result {\n        match self {\n            ApiError::Network(msg) =&gt; write!(f, \"Network error: {}\", msg),\n            ApiError::InvalidResponse(msg) =&gt; write!(f, \"Invalid response: {}\", msg),\n        }\n    }\n}\n\nimpl std::error::Error for ApiError {}\n\n#[tanu::test]\nasync fn test_with_custom_error() -&gt; Result&lt;(), ApiError&gt; {\n    let response = client.get(\"/api/endpoint\").send().await\n        .map_err(|e| ApiError::Network(e.to_string()))?;\n\n    if !response.status().is_success() {\n        return Err(ApiError::InvalidResponse(\n            format!(\"Status: {}\", response.status())\n        ));\n    }\n    Ok(())\n}\n\n// Simple string errors\n#[tanu::test]\nasync fn test_with_string_error() -&gt; Result&lt;(), String&gt; {\n    let response = client.get(\"/api/endpoint\").send().await\n        .map_err(|e| format!(\"Request failed: {}\", e))?;\n\n    if !response.status().is_success() {\n        return Err(format!(\"Expected success, got: {}\", response.status()));\n    }\n    Ok(())\n}\n</code></pre> <p>Recommendation: Use <code>eyre::Result</code> for best experience</p> <p>While tanu supports <code>anyhow::Result</code>, <code>std::result::Result</code>, and custom error types, we strongly recommend using <code>eyre::Result</code> for the following reasons:</p> <ul> <li>Seamless integration: Tanu's <code>check!</code>, <code>check_eq!</code>, and other assertion macros return <code>eyre::Result</code>, providing perfect compatibility</li> <li>Colored backtraces: eyre provides beautiful, colored error backtraces that make debugging much easier</li> <li>Rich error context: eyre excels at capturing and displaying error context chains</li> <li>Zero friction: No need for manual error conversions or custom assertion logic</li> <li>Consistent experience: Best integration with tanu's error reporting and TUI</li> </ul> <p>Alternative Result types: - Use <code>anyhow::Result</code> when you need compatibility with existing anyhow-based code (requires manual assertions) - Use custom error types when you want specific error categorization or need to implement particular error handling logic - Use <code>Result&lt;(), String&gt;</code> for simple tests where detailed error handling isn't critical</p> <p>Important: When using non-eyre Result types, you cannot use tanu's <code>check!</code> macros directly since they return <code>eyre::Result</code>. You'll need to write manual assertions as shown in the examples above.</p> <p>By following these best practices, you'll create maintainable, reliable, and effective API tests with tanu.</p>"},{"location":"command-line-option/","title":"Command Line Options","text":""},{"location":"command-line-option/#test","title":"<code>test</code>","text":"<p>Run tests with tanu.</p>"},{"location":"command-line-option/#options","title":"Options","text":"<ul> <li><code>--capture-http</code>         Capture http debug logs</li> <li><code>--capture-rust</code>         Capture Rust \"log\" crate based logs. This is usefull in the following two cases 1) tanu failed unexpectedly and you would want to see the tanu's internal logs. 2) you would want to see logs produced from your tests that uses \"log\" crate</li> <li><code>-p, --projects &lt;PROJECTS&gt;</code>  Run only the specified projects. This option can be specified multiple times e.g. --projects dev --projects staging</li> <li><code>-m, --modules &lt;MODULES&gt;</code>    Run only the specified modules. This option can be specified multiple times e.g. --modules foo --modules bar</li> <li><code>-t, --tests &lt;TESTS&gt;</code>        Run only the specified test cases. This option can be specified multiple times e.g. --tests a ---tests b</li> <li><code>--reporter &lt;REPORTER&gt;</code>  Specify the reporter to use. Default is \"table\". Possible values are \"table\", \"list\" and \"null\"</li> <li><code>-c, --concurrency &lt;NUMBER&gt;</code> Specify the maximum number of tests to run in parallel. When unspecified, all tests run in parallel.</li> <li><code>--color &lt;WHEN&gt;</code>         Control when colored output is used. Possible values are \"auto\" (default), \"always\", or \"never\". Environment variable <code>CARGO_TERM_COLOR</code> is also respected.</li> </ul>"},{"location":"command-line-option/#tui","title":"<code>tui</code>","text":"<p>Launch the TUI (Text User Interface) for tanu.</p>"},{"location":"command-line-option/#options_1","title":"Options","text":"<ul> <li><code>--log-level &lt;LOG_LEVEL&gt;</code>            [default: Info]</li> <li><code>--tanu-log-level &lt;TANU_LOG_LEVEL&gt;</code>  [default: Info]</li> <li><code>-c, --concurrency &lt;NUMBER&gt;</code> Specify the maximum number of tests to run in parallel. Default is the number of logical CPU cores</li> </ul>"},{"location":"command-line-option/#ls","title":"<code>ls</code>","text":"<p>List test cases.</p>"},{"location":"command-line-option/#help","title":"<code>help</code>","text":"<p>Print this message or the help of the given subcommand(s).</p>"},{"location":"command-line-option/#options_2","title":"Options","text":"<ul> <li><code>-h, --help</code> Print help.</li> <li><code>-V, --version</code> Print version.</li> </ul>"},{"location":"configuration/","title":"tanu.toml Configuration","text":"<p>The <code>tanu.toml</code> file is used to configure different project environments for the tanu application.</p>"},{"location":"configuration/#structure","title":"Structure","text":"<p>The [[projects]] tables in the tanu.toml file allow you to define different configurations for various environments. This is inspired by Playwright and enables you to iterate the same set of tests with different configurations or environments. You can make as many projects as you want.</p> <p>The <code>tanu.toml</code> file consists of multiple <code>[[projects]]</code> tables, each representing a different environment. Each table contains the following fields:</p> <ul> <li><code>name</code>: The name of the project (e.g., \"dev\", \"staging\", \"production\").</li> <li><code>test_ignore</code>: A list of test cases to ignore for the environment.</li> </ul>"},{"location":"configuration/#example","title":"Example","text":"<p>Below is an example of a <code>tanu.toml</code> file:</p> <pre><code>[tanu]\npayload.color_theme: \"tomorrow-night\"  # Replace with your preferred theme name\n\n[[projects]]\nname = \"staging\"\ntest_ignore = [\n  \"feature_flag::feature_flag_enabled\",\n  \"feature_flag::feature_flag_disabled\",\n]\nretry.count = 3\nretry.factor = 2.0\nretry.jitter = true\nretry.min_delay = \"1s\"\nretry.max_delay = \"60s\"\n\n[[projects]]\nname = \"production\"\ntest_ignore = []\nretry.count = 3\nretry.factor = 2.0\nretry.jitter = true\nretry.min_delay = \"1s\"\nretry.max_delay = \"60s\"\n</code></pre>"},{"location":"configuration/#retry","title":"Retry","text":"<p>This section describes the HTTP retry configuration for the project. All values are optional. If the retry configuration is entirely omitted, retries are disabled by default. If configured, the Tanu runner will perform retry attempts if a request fails. - <code>retry.count</code>: The number of retry attempts. Default is 0. - <code>retry.factor</code>: The factor for exponential backoff. Default is 2.0. - <code>retry.jitter</code>: A boolean to enable or disable backoff jitter. Default is false. - <code>retry.min_delay</code>: The minimum delay for backoff. Default is \"1s\". - <code>retry.max_delay</code>: The maximum delay for backoff. Default is \"60s\".</p>"},{"location":"configuration/#user-defined-settings","title":"User defined settings","text":"<p>tanu allows you to set user-defined settings in <code>tanu.toml</code>. You can set arbitrary key-value pairs under each project setting.</p> <p>Here is an example specifying different <code>base_url</code> values for staging and production environments:</p> <pre><code>[[projects]]\nname = \"staging\"\nbase_url = \"https://api.production.foobar.com\"\n\n[[projects]]\nname = \"production\"\nbase_url = \"https://api.staging.foobar.com\"\n</code></pre> <p>In your test code, you can retrieve the value for the current project using the following method: <pre><code>tanu::get_config().get_str(\"base_url\")?;\n</code></pre></p> <p>If the value is not string, you can use other methods to retrieve it:</p> <ul> <li>get_int</li> <li>get_float</li> <li>get_bool</li> <li>get_datetime</li> <li>get_array</li> <li>get_object</li> </ul>"},{"location":"configuration/#environment-variables","title":"Environment variables","text":"<p>Tanu also allows you to set user-defined settings in a <code>.env</code> file. Secret settings like API keys should not be stored in plain text; instead, environment variables should be used. Any environment variable prefixed with <code>TANU_{PROJECT}_{NAME}</code> will be exposed as a configuration. For example, an API key set in the <code>TANU_STAGING_API_KEY</code> environment variable can be accessed using <code>tanu::get_config().get_str(\"api_key\")</code>.</p>"},{"location":"configuration/#theme","title":"Theme","text":"<p>You can customize the appearance of Tanu's interface by selecting a color theme.</p> <p>To change the theme, add the following to your <code>tanu.toml</code> configuration file:</p> <pre><code>[tanu]\npayload.color_theme = \"tomorrow-night\"  # Replace with your preferred theme name\n</code></pre> <p>Note</p> <p>The color theme setting primarily affects the Payload tab in the TUI, where it's used to colorize and syntax-highlight response payloads (particularly JSON responses). This makes the API responses more readable and helps you quickly identify different elements in the response data.</p>"},{"location":"configuration/#available-themes","title":"Available Themes","text":"<p>Tanu ships with all Base16 themes, providing a consistent color palette across different interfaces. Available themes include:</p> <ul> <li><code>3024</code></li> <li><code>apathy</code></li> <li><code>ashes</code></li> <li><code>atelier-cave</code></li> <li><code>atelier-dune</code></li> <li><code>atelier-estuary</code></li> <li><code>atelier-forest</code></li> <li><code>atelier-heath</code></li> <li><code>atelier-lakeside</code></li> <li><code>atelier-plateau</code></li> <li><code>atelier-savanna</code></li> <li><code>atelier-seaside</code></li> <li><code>atelier-sulphurpool</code></li> <li><code>atlas</code></li> <li><code>bespin</code></li> <li><code>black-metal</code></li> <li><code>brewer</code></li> <li><code>bright</code></li> <li><code>brushtrees</code></li> <li><code>chalk</code></li> <li><code>circus</code></li> <li><code>classic</code></li> <li><code>codeschool</code></li> <li><code>cupcake</code></li> <li><code>cupertino</code></li> <li><code>darktooth</code></li> <li><code>default</code></li> <li><code>eighties</code></li> <li><code>embers</code></li> <li><code>flat</code></li> <li><code>fruit-soda</code></li> <li><code>github</code></li> <li><code>google</code></li> <li><code>grayscale</code></li> <li><code>greenscreen</code></li> <li><code>gruvbox</code></li> <li><code>harmonic</code></li> <li><code>hopscotch</code></li> <li><code>irblack</code></li> <li><code>isotope</code></li> <li><code>macintosh</code></li> <li><code>marrakesh</code></li> <li><code>materia</code></li> <li><code>material</code></li> <li><code>mellow</code></li> <li><code>mexico</code></li> <li><code>mocha</code></li> <li><code>monokai</code></li> <li><code>nord</code></li> <li><code>ocean</code></li> <li><code>oceanicnext</code></li> <li><code>one</code></li> <li><code>onedark</code></li> <li><code>papercolor</code></li> <li><code>paraiso</code></li> <li><code>phd</code></li> <li><code>pico</code></li> <li><code>pop</code></li> <li><code>porple</code></li> <li><code>railscasts</code></li> <li><code>rebecca</code></li> <li><code>seti</code></li> <li><code>shapeshifter</code></li> <li><code>solarflare</code></li> <li><code>solarized</code></li> <li><code>spacemacs</code></li> <li><code>summerfruit</code></li> <li><code>tomorrow</code></li> <li><code>tomorrow-night</code></li> <li><code>tube</code></li> <li><code>twilight</code></li> <li><code>unikitty</code></li> <li><code>woodland</code></li> <li><code>xcode</code></li> <li><code>zenburn</code></li> </ul>"},{"location":"faq/","title":"Frequently Asked Questions (FAQ)","text":"<p>tags:   - FAQ   - Getting Started   - Configuration   - HTTP</p>"},{"location":"faq/#general-questions","title":"General Questions","text":""},{"location":"faq/#what-is-tanu","title":"What is tanu?","text":"<p>Tanu is a high-performance, async-friendly WebAPI testing framework for Rust. It's designed to be fast, type-safe, ergonomic, and easily extensible with full support for concurrency and async operations.</p>"},{"location":"faq/#how-is-tanu-different-from-using-standard-rust-test-framework-with-reqwest","title":"How is tanu different from using standard Rust test framework with reqwest?","text":"<p>While you can write API tests using <code>#[test]</code> with tokio and reqwest, tanu provides: - Dedicated test discovery and execution system - Built-in HTTP client with logging - Ergonomic assertion macros designed for API testing - Terminal UI for interactive test execution - Configuration system for multiple environments - Parameterized test support</p>"},{"location":"faq/#is-tanu-production-ready","title":"Is tanu production-ready?","text":"<p>Yes, tanu is actively developed and used for testing production APIs. The framework follows semantic versioning and maintains backward compatibility.</p>"},{"location":"faq/#installation-setup","title":"Installation &amp; Setup","text":""},{"location":"faq/#what-are-the-minimum-requirements","title":"What are the minimum requirements?","text":"<ul> <li>Rust 1.70 or later</li> <li>Cargo package manager</li> <li>tokio runtime for async support</li> </ul>"},{"location":"faq/#how-do-i-install-tanu","title":"How do I install tanu?","text":"<p>Add tanu to your Cargo.toml: <pre><code>cargo add tanu\ncargo add tokio --features full\n</code></pre></p>"},{"location":"faq/#can-i-use-tanu-in-an-existing-rust-project","title":"Can I use tanu in an existing Rust project?","text":"<p>Yes! Tanu can be added to any Rust project. You can create a separate binary for your tests or integrate them into your existing test suite.</p>"},{"location":"faq/#writing-tests","title":"Writing Tests","text":""},{"location":"faq/#how-do-i-write-a-basic-test","title":"How do I write a basic test?","text":"<pre><code>use tanu::{check, eyre, http::Client};\n\n#[tanu::test]\nasync fn my_test() -&gt; eyre::Result&lt;()&gt; {\n    let client = Client::new();\n    let response = client.get(\"https://api.example.com\").send().await?;\n    check!(response.status().is_success());\n    Ok(())\n}\n</code></pre>"},{"location":"faq/#can-i-use-parameterized-tests","title":"Can I use parameterized tests?","text":"<p>Yes! Use multiple <code>#[tanu::test(param)]</code> attributes: <pre><code>#[tanu::test(200)]\n#[tanu::test(404)]\n#[tanu::test(500)]\nasync fn test_status_codes(status: u16) -&gt; eyre::Result&lt;()&gt; {\n    // Test implementation\n    Ok(())\n}\n</code></pre></p>"},{"location":"faq/#how-do-i-handle-authentication","title":"How do I handle authentication?","text":"<p>Add headers to your requests: <pre><code>let response = client\n    .get(\"https://api.example.com/protected\")\n    .header(\"authorization\", \"Bearer your-token\")\n    .send()\n    .await?;\n</code></pre></p>"},{"location":"faq/#what-assertion-macros-are-available","title":"What assertion macros are available?","text":"<ul> <li><code>check!(condition)</code> - Basic boolean assertion</li> <li><code>check_eq!(expected, actual)</code> - Equality assertion</li> <li><code>check_ne!(expected, actual)</code> - Non-equality assertion</li> <li><code>check_str_eq!(expected, actual)</code> - String equality with better diff output</li> </ul>"},{"location":"faq/#http-features","title":"HTTP Features","text":""},{"location":"faq/#does-tanu-support-cookies","title":"Does tanu support cookies?","text":"<p>Yes! Enable the cookies feature: <pre><code>tanu = { version = \"*\", features = [\"cookies\"] }\n</code></pre></p> <p>Then use the cookies API: <pre><code>let cookies = response.cookies();\nfor cookie in cookies {\n    println!(\"{}={}\", cookie.name(), cookie.value());\n}\n</code></pre></p>"},{"location":"faq/#what-http-methods-are-supported","title":"What HTTP methods are supported?","text":"<p>All standard HTTP methods: GET, POST, PUT, PATCH, DELETE, HEAD, OPTIONS.</p>"},{"location":"faq/#can-i-send-json-data","title":"Can I send JSON data?","text":"<p>Yes, with the json feature enabled: <pre><code>let response = client\n    .post(\"https://api.example.com/users\")\n    .json(&amp;user_data)\n    .send()\n    .await?;\n</code></pre></p>"},{"location":"faq/#how-do-i-handle-different-content-types","title":"How do I handle different content types?","text":"<p>Use appropriate headers: <pre><code>let response = client\n    .post(\"https://api.example.com/data\")\n    .header(\"content-type\", \"application/xml\")\n    .body(xml_data)\n    .send()\n    .await?;\n</code></pre></p>"},{"location":"faq/#configuration","title":"Configuration","text":""},{"location":"faq/#how-do-i-configure-different-environments","title":"How do I configure different environments?","text":"<p>Create a <code>tanu.toml</code> file: <pre><code>[[projects]]\nname = \"staging\"\nbase_url = \"https://staging.api.example.com\"\n\n[[projects]]\nname = \"production\"\nbase_url = \"https://api.example.com\"\n</code></pre></p>"},{"location":"faq/#can-i-ignore-specific-tests","title":"Can I ignore specific tests?","text":"<p>Yes, use the <code>test_ignore</code> configuration: <pre><code>[[projects]]\nname = \"default\"\ntest_ignore = [\"slow_test\", \"flaky_test\"]\n</code></pre></p>"},{"location":"faq/#how-do-i-configure-retry-behavior","title":"How do I configure retry behavior?","text":"<p>Add retry configuration to your project: <pre><code>[[projects]]\nname = \"default\"\nretry.count = 3\nretry.factor = 2.0\nretry.jitter = true\n</code></pre></p>"},{"location":"faq/#running-tests","title":"Running Tests","text":""},{"location":"faq/#how-do-i-run-tests","title":"How do I run tests?","text":"<pre><code>cargo run                    # Run all tests\ncargo run test             # Run all tests (explicit)\ncargo run test -t pattern  # Run tests matching pattern\n</code></pre>"},{"location":"faq/#can-i-run-tests-in-parallel","title":"Can I run tests in parallel?","text":"<p>Yes, tanu runs tests concurrently by default. You can control concurrency with command-line options.</p>"},{"location":"faq/#how-do-i-use-the-tui-mode","title":"How do I use the TUI mode?","text":"<pre><code>cargo run tui\n</code></pre> <p>This opens an interactive terminal interface for running and monitoring tests.</p>"},{"location":"faq/#troubleshooting","title":"Troubleshooting","text":""},{"location":"faq/#my-tests-are-failing-with-connection-errors","title":"My tests are failing with connection errors","text":"<ul> <li>Check if the API endpoint is accessible</li> <li>Verify network connectivity</li> <li>Consider timeouts and retry configuration</li> <li>Check if authentication is required</li> </ul>"},{"location":"faq/#im-getting-function-not-found-errors","title":"I'm getting \"function not found\" errors","text":"<p>Make sure you've added the required features to your Cargo.toml: <pre><code>tanu = { version = \"*\", features = [\"json\", \"cookies\"] }\n</code></pre></p>"},{"location":"faq/#tests-work-individually-but-fail-when-run-together","title":"Tests work individually but fail when run together","text":"<p>This might be due to: - Shared state between tests - Rate limiting from the API - Authentication token expiration - Resource cleanup issues</p>"},{"location":"faq/#how-do-i-debug-http-requests","title":"How do I debug HTTP requests?","text":"<p>Tanu automatically captures HTTP request/response logs. Use the TUI mode to inspect detailed request information.</p>"},{"location":"faq/#performance","title":"Performance","text":""},{"location":"faq/#how-fast-is-tanu-compared-to-other-tools","title":"How fast is tanu compared to other tools?","text":"<p>Tanu is built in Rust and leverages zero-cost abstractions for minimal overhead. It typically outperforms JavaScript and Python-based testing frameworks.</p>"},{"location":"faq/#can-i-control-test-execution-speed","title":"Can I control test execution speed?","text":"<p>Yes, through configuration: - Adjust concurrency levels - Configure timeouts - Use retry settings appropriately - Consider rate limiting for API protection</p>"},{"location":"faq/#integration","title":"Integration","text":""},{"location":"faq/#can-i-use-tanu-in-cicd-pipelines","title":"Can I use tanu in CI/CD pipelines?","text":"<p>Yes! Tanu works well in CI/CD environments. Use the CLI mode for automated testing: <pre><code>cargo run test --reporter json &gt; results.json\n</code></pre></p>"},{"location":"faq/#how-do-i-integrate-with-existing-test-suites","title":"How do I integrate with existing test suites?","text":"<p>Tanu tests can run alongside standard Rust tests. You can organize them in separate modules or binaries as needed.</p>"},{"location":"faq/#can-i-generate-test-reports","title":"Can I generate test reports?","text":"<p>Yes, tanu supports various output formats including JSON for integration with reporting tools.</p>"},{"location":"faq/#contributing","title":"Contributing","text":""},{"location":"faq/#how-can-i-contribute-to-tanu","title":"How can I contribute to tanu?","text":"<ul> <li>Report bugs and feature requests on GitHub</li> <li>Submit pull requests with improvements</li> <li>Write documentation and examples</li> <li>Share your experience with the community</li> </ul>"},{"location":"faq/#where-can-i-get-help","title":"Where can I get help?","text":"<ul> <li>Check this FAQ and documentation</li> <li>Search existing GitHub issues</li> <li>Create a new issue for bugs or feature requests</li> <li>Join community discussions</li> </ul>"},{"location":"getting-started/","title":"Getting Started","text":"<p>To install <code>tanu</code> from crates.io, you need to have Rust and Cargo installed on your system. If you don't have Rust installed, you can install it by following the instructions on the official Rust website.</p> <p>Once you have Rust and Cargo installed, create an example project by running the following commands in your terminal:</p> <pre><code>cargo new example\ncd example\n</code></pre> <p>Next, you can install <code>tanu</code> and <code>tokio</code> by running the following commands in your terminal:</p> <pre><code>cargo add tanu\ncargo add tokio --features full\n</code></pre> <p>Open <code>src/main.rs</code> in your editor, and replace its contents with the following code:</p> <pre><code>use tanu::eyre;\n\n#[tanu::main]\n#[tokio::main]\nasync fn main() -&gt; eyre::Result&lt;()&gt; {\n    let runner = run();\n    let app = tanu::App::new();\n    app.run(runner).await?;\n    Ok(())\n}\n</code></pre> <p>This code sets up a basic <code>tanu</code> application using <code>tokio</code> for asynchronous runtime and <code>eyre</code> for error handling.</p> <p>To run your application, use the following command in your terminal:</p> <pre><code>cargo run\n</code></pre> <p>you will see the output as follows: <pre><code>tanu - High-performance and async-friendly WebAPI testing framework for Rust\n\nUsage: tanu-examples &lt;COMMAND&gt;\n\nCommands:\n  test  Run tests in CLI mode\n  tui   Run tests in TUI mode\n  ls    List test cases\n  help  Print this message or the help of the given subcommand(s)\n\nOptions:\n  -h, --help     Print help\n  -V, --version  Print version\n</code></pre></p> <p>If you want to run tests, you can use:</p> <pre><code>cargo run test\n</code></pre> <p>If there are no tests defined, you should see the following output:</p> <pre><code>No tests have been defined yet.\n</code></pre> <p>Next, define your test case. As you can see below, the function has the <code>#[tanu::test]</code> attribute. This attribute parses the test function and automatically registers it in the tanu's test runner. The test function has to be \"async\" and return a <code>Result&lt;T, E&gt;</code> type.</p> <p>Supported Error Types</p> <p>Tanu supports various Result types for flexible error handling:</p> <ul> <li><code>eyre::Result&lt;()&gt;</code> (recommended) - Provides colored backtraces and seamless integration with tanu's assertion macros</li> <li><code>anyhow::Result&lt;()&gt;</code> - Compatible with existing anyhow-based code</li> <li><code>std::result::Result&lt;(), E&gt;</code> - Standard Rust Result type with custom error types or simple errors like <code>String</code></li> </ul> <p>For the best experience, we recommend using <code>eyre::Result</code> as it integrates perfectly with tanu's <code>check!</code> macros and provides excellent error reporting. For more details on error handling best practices, see our Best Practices guide.</p> <pre><code>#[tanu::test]\nasync fn get() -&gt; eyre::Result&lt;()&gt; {\n    Ok(())\n}\n</code></pre> <p>Now, define the test assertions in the function:</p> <pre><code>use tanu::{check, eyre, http::Client};\n\n#[tanu::test]\nasync fn get() -&gt; eyre::Result&lt;()&gt; {\n    let http = Client::new();\n    let res = http.get(\"https://httpbin.org/get\").send().await?;\n    check!(res.status().is_success());\n    Ok(())\n}\n</code></pre> <p>Run the tanu test runner again:</p> <pre><code>cargo run test\n</code></pre> <p>This time you should see the test execution in your terminal like this:</p> <pre><code>\u2713 [default] crate::get\n</code></pre> <p>tanu offers a TUI-based test runner. To run in TUI mode, use the following command:</p> <pre><code>cargo run tui\n</code></pre> <p>Congratulations! You have successfully set up a basic <code>tanu</code> application. For more advanced usage and features, please refer to the official documentation.</p>"},{"location":"report/","title":"Allure Reports","text":""},{"location":"report/#overview","title":"Overview","text":"<p><code>tanu</code> integrates with the tanu-allure reporter, which emits Allure-compatible JSON for each executed test. The reporter plugs into <code>tanu_core::Reporter</code>, so HTTP calls, assertions, and timings automatically flow into Allure dashboards without extra plumbing. See https://github.com/tanu-rs/tanu-allure for more information.</p> <p></p>"},{"location":"tags/","title":"Tags","text":"<p>Browse documentation by topic:</p> <p>[TAGS]</p>"},{"location":"tags/#available-tags","title":"Available Tags","text":"<ul> <li>HTTP - HTTP client features, requests, and responses</li> <li>Testing - Test attributes, assertions, and best practices  </li> <li>Configuration - Project configuration and environment setup</li> <li>API - API reference and usage examples</li> <li>Rust - Rust-specific features and patterns</li> </ul>"},{"location":"tui/","title":"TUI","text":"<p>In TUI mode, you can select and execute a test case and see the result more interactively.</p> <p></p>"},{"location":"tui/#commands","title":"Commands","text":""},{"location":"tui/#navigation","title":"Navigation","text":"<ul> <li><code>Tab</code>: Switch between panes</li> <li><code>\u2192</code>: Navigate to next pane</li> <li><code>\u2190</code>: Navigate to previous pane</li> <li><code>\u2191</code>: Move cursor up</li> <li><code>\u2193</code>: Move cursor down</li> <li><code>Enter</code>: Expand/collapse project, module or test case in the list</li> </ul>"},{"location":"tui/#scrolling","title":"Scrolling","text":"<ul> <li><code>CTRL+U</code>: Scroll up half the screen</li> <li><code>CTRL+D</code>: Scroll down half the screen</li> <li><code>g</code>: Scroll to the top of the screen</li> <li><code>G</code>: Scroll to the bottom of the screen</li> </ul>"},{"location":"tui/#test-operations","title":"Test Operations","text":"<ul> <li><code>1</code>: Run all test cases</li> <li><code>2</code>: Run only the selected test cases</li> <li><code>Space</code>: Mark/unmark a test case for selection (use with <code>2</code> to run selected tests)</li> </ul>"},{"location":"tui/#view-control","title":"View Control","text":"<ul> <li><code>z</code>: Maximize/minimize the current pane</li> <li><code>?</code>: Show help panel with available commands</li> </ul>"},{"location":"tui/#general","title":"General","text":"<ul> <li><code>q</code>: Quit the TUI mode</li> <li><code>Esc</code>: Cancel current operation or close modal dialogs</li> </ul>"},{"location":"tui/#tips","title":"Tips","text":"<ul> <li>Use keyboard navigation to quickly move between test cases</li> <li>Maximize a pane with <code>z</code> when you need to see more details</li> <li>Mark multiple tests with <code>Space</code> before executing them with <code>2</code></li> </ul>"}]}